This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-14T04:58:37.780Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.gitignore
cmd/detail/main.go
cmd/list/main.go
cmd/migrate/main.go
cmd/test_cmd/main.go
go.mod
go.sum
internal/db/config.go
internal/db/connection.go
internal/db/hoe.go
internal/db/migrate.go
internal/db/types.go
internal/definitions/config.go
internal/definitions/const.go
internal/definitions/site.go
internal/interfaces/scraper.go
internal/models/hoe.go
internal/models/report.go
internal/models/reporter.go
internal/repository/hoe.go
internal/scrapers/factory.go
internal/scrapers/gaito/detail.go
internal/scrapers/gaito/list.go
internal/scrapers/gaito/report.go
internal/scrapers/gaito/scraper.go
internal/scrapers/gaito/selectors.go
internal/service/hoe.go
internal/utils/browser/connect.go
internal/utils/browser/element.go
internal/utils/browser/rate_limit.go
internal/utils/browser/retry.go
internal/utils/common.go
internal/utils/errutil/handler.go
internal/utils/logutil/handler.go
internal/utils/logutil/level.go
internal/utils/setuputil/setup.go

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# Binary files
*.exe
*.exe~
*.dll
*.so
*.dylib

# Binary folder (common Go build output)
/bin/

# Go specific
*.test
*.out

# IDE stuff
.idea/
.vscode/
*.swp
*.swo

# OS generated files
.DS_Store
.DS_Store?
._*

================
File: cmd/detail/main.go
================
package main

import (
	"github.com/haovoanh28/gai-webscraper/internal/utils/setuputil"
)

func main() {
	appContext, err := setuputil.CreateAppContext()
	if err != nil {
		panic(err)
	}

	// Example url
	url := "/gai-goi/chi-tiet/56042/hot-girl-diep-anhmat-xinh-nguc-dep-bu-cu-dieu-luyen"

	hoe, err := appContext.Scraper.ProcessDetailPage(url)
	if err != nil {
		appContext.Logger.Fatal(err.Error())
	}

	if hoe != nil {
		hoe.Print()
	}
}

================
File: cmd/list/main.go
================
package main

import (
	"fmt"

	"github.com/haovoanh28/gai-webscraper/internal/utils/setuputil"
)

func main() {
	appContext, err := setuputil.CreateAppContext()
	if err != nil {
		panic(err)
	}

	urlList, err := appContext.Scraper.ProcessListPage()
	if err != nil {
		appContext.Logger.Fatal("process list page", err.Error())
	}

	if len(urlList) == 0 {
		appContext.Logger.Warn("No items found (Maybe Cloudflare block ?)")
	} else {
		appContext.Logger.Info(fmt.Sprintf("Found %d items\n", len(urlList)))

		for _, url := range urlList {
			appContext.Logger.Info(url)
		}
	}
}

================
File: cmd/migrate/main.go
================
package main

import (
	"github.com/haovoanh28/gai-webscraper/internal/db"
)

func main() {
	dbConfig := db.NewConfig()
	dbo, err := db.GetDB(dbConfig)
	if err != nil {
		panic(err)
	}

	if err := dbo.Migrate(); err != nil {
		panic(err)
	}
}

================
File: cmd/test_cmd/main.go
================
package testcmd

import "github.com/haovoanh28/gai-webscraper/internal/db"

func main() {
	dbConfig := db.NewConfig()
	db, err := db.GetDB(dbConfig)
	if err != nil {
		panic(err)
	}

}

================
File: go.mod
================
module github.com/haovoanh28/gai-webscraper

go 1.23

toolchain go1.23.2

require (
	github.com/chromedp/cdproto v0.0.0-20241014181340-cb3a7a1d51d7
	github.com/chromedp/chromedp v0.11.0
)

require (
	filippo.io/edwards25519 v1.1.0 // indirect
	github.com/chromedp/sysutil v1.1.0 // indirect
	github.com/go-rod/rod v0.116.2 // indirect
	github.com/go-rod/stealth v0.4.9 // indirect
	github.com/go-sql-driver/mysql v1.8.1 // indirect
	github.com/gobwas/httphead v0.1.0 // indirect
	github.com/gobwas/pool v0.2.1 // indirect
	github.com/gobwas/ws v1.4.0 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/ysmood/fetchup v0.2.4 // indirect
	github.com/ysmood/goob v0.4.0 // indirect
	github.com/ysmood/got v0.40.0 // indirect
	github.com/ysmood/gson v0.7.3 // indirect
	github.com/ysmood/leakless v0.9.0 // indirect
	golang.org/x/sys v0.26.0 // indirect
	golang.org/x/text v0.20.0 // indirect
	gorm.io/driver/mysql v1.5.7 // indirect
	gorm.io/gorm v1.25.12 // indirect
)

================
File: go.sum
================
filippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=
filippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=
github.com/chromedp/cdproto v0.0.0-20241003230502-a4a8f7c660df/go.mod h1:GKljq0VrfU4D5yc+2qA6OVr8pmO/MBbPEWqWQ/oqGEs=
github.com/chromedp/cdproto v0.0.0-20241014181340-cb3a7a1d51d7 h1:VDBgUGgdCBw9lTKwp0KPExhnqmGfGVJQTER2MehoICk=
github.com/chromedp/cdproto v0.0.0-20241014181340-cb3a7a1d51d7/go.mod h1:GKljq0VrfU4D5yc+2qA6OVr8pmO/MBbPEWqWQ/oqGEs=
github.com/chromedp/chromedp v0.11.0 h1:1PT6O4g39sBAFjlljIHTpxmCSk8meeYL6+R+oXH4bWA=
github.com/chromedp/chromedp v0.11.0/go.mod h1:jsD7OHrX0Qmskqb5Y4fn4jHnqquqW22rkMFgKbECsqg=
github.com/chromedp/sysutil v1.0.0/go.mod h1:kgWmDdq8fTzXYcKIBqIYvRRTnYb9aNS9moAV0xufSww=
github.com/chromedp/sysutil v1.1.0 h1:PUFNv5EcprjqXZD9nJb9b/c9ibAbxiYo4exNWZyipwM=
github.com/chromedp/sysutil v1.1.0/go.mod h1:WiThHUdltqCNKGc4gaU50XgYjwjYIhKWoHGPTUfWTJ8=
github.com/go-rod/rod v0.113.0/go.mod h1:aiedSEFg5DwG/fnNbUOTPMTTWX3MRj6vIs/a684Mthw=
github.com/go-rod/rod v0.116.2 h1:A5t2Ky2A+5eD/ZJQr1EfsQSe5rms5Xof/qj296e+ZqA=
github.com/go-rod/rod v0.116.2/go.mod h1:H+CMO9SCNc2TJ2WfrG+pKhITz57uGNYU43qYHh438Mg=
github.com/go-rod/stealth v0.4.9 h1:X2PmQk4DUF2wzw6GOsWjW/glb8K5ebnftbEvLh7MlZ4=
github.com/go-rod/stealth v0.4.9/go.mod h1:eAzyvw8c0iAd5nJJsSWeh0fQ5z94vCIfdi1hUmYDimc=
github.com/go-sql-driver/mysql v1.7.0/go.mod h1:OXbVy3sEdcQ2Doequ6Z5BW6fXNQTmx+9S1MCJN5yJMI=
github.com/go-sql-driver/mysql v1.8.1 h1:LedoTUt/eveggdHS9qUFC1EFSa8bU2+1pZjSRpvNJ1Y=
github.com/go-sql-driver/mysql v1.8.1/go.mod h1:wEBSXgmK//2ZFJyE+qWnIsVGmvmEKlqwuVSjsCm7DZg=
github.com/gobwas/httphead v0.1.0 h1:exrUm0f4YX0L7EBwZHuCF4GDp8aJfVeBrlLQrs6NqWU=
github.com/gobwas/httphead v0.1.0/go.mod h1:O/RXo79gxV8G+RqlR/otEwx4Q36zl9rqC5u12GKvMCM=
github.com/gobwas/pool v0.2.1 h1:xfeeEhW7pwmX8nuLVlqbzVc7udMDrwetjEv+TZIz1og=
github.com/gobwas/pool v0.2.1/go.mod h1:q8bcK0KcYlCgd9e7WYLm9LpyS+YeLd8JVDW6WezmKEw=
github.com/gobwas/ws v1.4.0 h1:CTaoG1tojrh4ucGPcoJFiAQUAsEWekEWvLy7GsVNqGs=
github.com/gobwas/ws v1.4.0/go.mod h1:G3gNqMNtPppf5XUz7O4shetPpcZ1VJ7zt18dlUeakrc=
github.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=
github.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=
github.com/jinzhu/now v1.1.5 h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=
github.com/jinzhu/now v1.1.5/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=
github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
github.com/ledongthuc/pdf v0.0.0-20220302134840-0c2507a12d80 h1:6Yzfa6GP0rIo/kULo2bwGEkFvCePZ3qHDDTC3/J9Swo=
github.com/ledongthuc/pdf v0.0.0-20220302134840-0c2507a12d80/go.mod h1:imJHygn/1yfhB7XSJJKlFZKl/J+dCPAknuiaGOshXAs=
github.com/mailru/easyjson v0.7.7 h1:UGYAvKxe3sBsEDzO8ZeWOSlIQfWFlxbzLZe7hwFURr0=
github.com/mailru/easyjson v0.7.7/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=
github.com/orisano/pixelmatch v0.0.0-20220722002657-fb0b55479cde h1:x0TT0RDC7UhAVbbWWBzr41ElhJx5tXPWkIHA2HWPRuw=
github.com/orisano/pixelmatch v0.0.0-20220722002657-fb0b55479cde/go.mod h1:nZgzbfBr3hhjoZnS66nKrHmduYNpc34ny7RK4z5/HM0=
github.com/ysmood/fetchup v0.2.3 h1:ulX+SonA0Vma5zUFXtv52Kzip/xe7aj4vqT5AJwQ+ZQ=
github.com/ysmood/fetchup v0.2.3/go.mod h1:xhibcRKziSvol0H1/pj33dnKrYyI2ebIvz5cOOkYGns=
github.com/ysmood/fetchup v0.2.4 h1:2kfWr/UrdiHg4KYRrxL2Jcrqx4DZYD+OtWu7WPBZl5o=
github.com/ysmood/fetchup v0.2.4/go.mod h1:hbysoq65PXL0NQeNzUczNYIKpwpkwFL4LXMDEvIQq9A=
github.com/ysmood/goob v0.4.0 h1:HsxXhyLBeGzWXnqVKtmT9qM7EuVs/XOgkX7T6r1o1AQ=
github.com/ysmood/goob v0.4.0/go.mod h1:u6yx7ZhS4Exf2MwciFr6nIM8knHQIE22lFpWHnfql18=
github.com/ysmood/gop v0.0.2/go.mod h1:rr5z2z27oGEbyB787hpEcx4ab8cCiPnKxn0SUHt6xzk=
github.com/ysmood/got v0.34.1/go.mod h1:yddyjq/PmAf08RMLSwDjPyCvHvYed+WjHnQxpH851LM=
github.com/ysmood/got v0.40.0 h1:ZQk1B55zIvS7zflRrkGfPDrPG3d7+JOza1ZkNxcc74Q=
github.com/ysmood/got v0.40.0/go.mod h1:W7DdpuX6skL3NszLmAsC5hT7JAhuLZhByVzHTq874Qg=
github.com/ysmood/gotrace v0.6.0/go.mod h1:TzhIG7nHDry5//eYZDYcTzuJLYQIkykJzCRIo4/dzQM=
github.com/ysmood/gson v0.7.3 h1:QFkWbTH8MxyUTKPkVWAENJhxqdBa4lYTQWqZCiLG6kE=
github.com/ysmood/gson v0.7.3/go.mod h1:3Kzs5zDl21g5F/BlLTNcuAGAYLKt2lV5G8D1zF3RNmg=
github.com/ysmood/leakless v0.8.0/go.mod h1:R8iAXPRaG97QJwqxs74RdwzcRHT1SWCGTNqY8q0JvMQ=
github.com/ysmood/leakless v0.9.0 h1:qxCG5VirSBvmi3uynXFkcnLMzkphdh3xx5FtrORwDCU=
github.com/ysmood/leakless v0.9.0/go.mod h1:R8iAXPRaG97QJwqxs74RdwzcRHT1SWCGTNqY8q0JvMQ=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.26.0 h1:KHjCJyddX0LoSTb3J+vWpupP9p0oznkqVk/IfjymZbo=
golang.org/x/sys v0.26.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/text v0.20.0 h1:gK/Kv2otX8gz+wn7Rmb3vT96ZwuoxnQlY+HlJVj7Qug=
golang.org/x/text v0.20.0/go.mod h1:D4IsuqiFMhST5bX19pQ9ikHC2GsaKyk/oF+pn3ducp4=
gorm.io/driver/mysql v1.5.7 h1:MndhOPYOfEp2rHKgkZIhJ16eVUIRf2HmzgoPmh7FCWo=
gorm.io/driver/mysql v1.5.7/go.mod h1:sEtPWMiqiN1N1cMXoXmBbd8C6/l+TESwriotuRRpkDM=
gorm.io/gorm v1.25.7/go.mod h1:hbnx/Oo0ChWMn1BIhpy1oYozzpM15i4YPuHDmfYtwg8=
gorm.io/gorm v1.25.12 h1:I0u8i2hWQItBq1WfE0o2+WuL9+8L21K9e2HHSTE/0f8=
gorm.io/gorm v1.25.12/go.mod h1:xh7N7RHfYlNc5EmcI/El95gXusucDrQnHXe0+CgWcLQ=

================
File: internal/db/config.go
================
package db

import "fmt"

func NewConfig() *DBConfig {
	return &DBConfig{
		Host:     "127.0.0.1",
		Port:     "3306",
		User:     "hao",
		Password: "020899",
		DBName:   "gai-scraper",
	}
}

func (c *DBConfig) BuildConnectionString() string {
	return fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
		c.User, c.Password, c.Host, c.Port, c.DBName)
}

================
File: internal/db/connection.go
================
package db

import (
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

func GetDB(cfg *DBConfig) (*DBO, error) {
	db, err := gorm.Open(mysql.Open(cfg.BuildConnectionString()), &gorm.Config{})
	if err != nil {
		return nil, err
	}

	return &DBO{db: db}, nil
}

func (dbo *DBO) Close() {
	sqlDB, err := dbo.db.DB()
	if err != nil {
		panic(err)
	}

	err = sqlDB.Close()
	if err != nil {
		panic(err)
	}
}

================
File: internal/db/hoe.go
================
package db

import (
	"fmt"

	"github.com/haovoanh28/gai-webscraper/internal/models"
)

func (dbo *DBO) InsertHoe(hoeInfo *models.HoeInfo) error {
	transaction := dbo.db.Begin()

	if err := transaction.Create(hoeInfo).Error; err != nil {
		transaction.Rollback()
		return err
	}

	if err := transaction.Commit().Error; err != nil {
		transaction.Rollback()
		return err
	}

	fmt.Println("Inserted")
	hoeInfo.Print()

	return nil
}

================
File: internal/db/migrate.go
================
package db

import (
	"fmt"

	"github.com/haovoanh28/gai-webscraper/internal/models"
)

func (dbo *DBO) Migrate() error {
	err := dbo.db.AutoMigrate(&models.HoeInfo{})
	if err != nil {
		return fmt.Errorf("failed to migrate HoeInfo : %v", err)
	}

	err = dbo.db.AutoMigrate(&models.HoeReport{})
	if err != nil {
		return fmt.Errorf("failed to migrate HoeReport : %v", err)
	}

	return nil
}

================
File: internal/db/types.go
================
package db

import "gorm.io/gorm"

type DBConfig struct {
	Host     string
	Port     string
	User     string
	Password string
	DBName   string
}

type DBO struct {
	db *gorm.DB
}

================
File: internal/definitions/config.go
================
package definitions

import "github.com/haovoanh28/gai-webscraper/internal/utils/logutil"

type ScraperConfig struct {
	Site              SiteType
	BaseURL           string
	RequestsPerSecond float64
	Logger            *logutil.Logger
}

================
File: internal/definitions/const.go
================
package definitions

const (
	Gaito SiteType = "gaito"
	Gaigu SiteType = "gaigu"
)

var SiteConfigs = map[SiteType]string{
	Gaito: "https://gaito.love",
	Gaigu: "https://gaigu31.tv",
}

================
File: internal/definitions/site.go
================
package definitions

type SiteType string

type SiteConfig struct {
	BaseURL string
}

type SiteConfigMap map[SiteType]SiteConfig

================
File: internal/interfaces/scraper.go
================
package interfaces

import "github.com/haovoanh28/gai-webscraper/internal/models"

type Scraper interface {
	ProcessListPage() ([]string, error)
	ProcessDetailPage(url string) (*models.HoeInfo, error)
}

================
File: internal/models/hoe.go
================
package models

import (
	"fmt"
	"time"
)

type HoeInfo struct {
	ID        uint         `gorm:"primaryKey"`
	OriginID  string       `gorm:"column:origin_id;unique"`
	Url       string       `gorm:"column:url"`
	Name      string       `gorm:"column:name"`
	ImageUrl  string       `gorm:"column:image_url"`
	Price     string       `gorm:"column:price"`
	Phone     string       `gorm:"column:phone"`
	Address   string       `gorm:"column:address"`
	Provider  string       `gorm:"column:provider"`
	Status    string       `gorm:"column:status"`
	BirthYear string       `gorm:"column:birth_year"`
	Height    string       `gorm:"column:height"`
	Weight    string       `gorm:"column:weight"`
	Country   string       `gorm:"column:country"`
	Service   string       `gorm:"column:service"`
	Duration  string       `gorm:"column:duration"`
	WorkTime  string       `gorm:"column:work_time"`
	Site      string       `gorm:"column:site"`
	CreatedAt time.Time    `gorm:"column:created_at"`
	UpdatedAt time.Time    `gorm:"column:updated_at"`
	Reports   []*HoeReport `gorm:"foreignKey:HoeID;references:ID;constraint:OnDelete:CASCADE"`
}

func (HoeInfo) TableName() string {
	return "hoes"
}

func (hoe HoeInfo) Print() {
	fmt.Printf("=========== Hoe %s ===========\n", hoe.OriginID)
	fmt.Printf("Url: %s\n", hoe.Url)

	// Print all fields in Main info
	fmt.Printf("Name: %s\n", hoe.Name)
	fmt.Printf("Image url: %s\n", hoe.ImageUrl)
	fmt.Printf("Price: %s\n", hoe.Price)
	fmt.Printf("Phone: %s\n", hoe.Phone)
	fmt.Printf("Address: %s\n", hoe.Address)
	fmt.Printf("Provider: %s\n", hoe.Provider)
	fmt.Printf("Status: %s\n", hoe.Status)
	fmt.Printf("Birth year: %s\n", hoe.BirthYear)
	fmt.Printf("Height: %s\n", hoe.Height)
	fmt.Printf("Weight: %s\n", hoe.Weight)
	fmt.Printf("From: %s\n", hoe.Country)
	fmt.Printf("Service: %s\n", hoe.Service)
	fmt.Printf("Work Time: %s\n", hoe.WorkTime)
	fmt.Printf("Duration: %s\n", hoe.Duration)
	fmt.Printf("Report count: %d\n", len(hoe.Reports))

	fmt.Println("==============================")
	fmt.Print("\n\n")
}

================
File: internal/models/report.go
================
package models

import "time"

type HoeReport struct {
	ID        uint      `gorm:"primaryKey"`
	HoeID     uint      `gorm:"column:hoe_id"`
	ReportURL string    `gorm:"column:report_url"`
	CreatedAt time.Time `gorm:"column:created_at"`
	UpdatedAt time.Time `gorm:"column:updated_at"`
}

func (HoeReport) TableName() string {
	return "hoe_reports"
}

================
File: internal/models/reporter.go
================
package models

type Reporter struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	Url  string `json:"url"`
}

================
File: internal/repository/hoe.go
================
package repository

import (
	"github.com/haovoanh28/gai-webscraper/internal/db"
	"github.com/haovoanh28/gai-webscraper/internal/models"
)

type HoeRepository interface {
	Save(hoe *models.HoeInfo) error
}

type hoeRepo struct {
	dbo *db.DBO
}

func NewHoeRepository(dbo *db.DBO) HoeRepository {
	return &hoeRepo{dbo: dbo}
}

func (r *hoeRepo) Save(hoe *models.HoeInfo) error {
	return r.dbo.InsertHoe(hoe)
}

================
File: internal/scrapers/factory.go
================
package scrapers

import (
	"github.com/haovoanh28/gai-webscraper/internal/definitions"
	"github.com/haovoanh28/gai-webscraper/internal/interfaces"
	"github.com/haovoanh28/gai-webscraper/internal/scrapers/gaito"
)

func CreateScraper(baseConfig definitions.ScraperConfig) interfaces.Scraper {
	switch baseConfig.Site {
	case definitions.Gaito:
		return gaito.NewScraper(baseConfig)
	case definitions.Gaigu:
		return gaito.NewScraper(baseConfig)
	default:
		return nil
	}
}

================
File: internal/scrapers/gaito/detail.go
================
package gaito

import (
	"strings"
	"time"

	"github.com/go-rod/rod/lib/proto"
	"github.com/haovoanh28/gai-webscraper/internal/models"
	"github.com/haovoanh28/gai-webscraper/internal/utils"
	"github.com/haovoanh28/gai-webscraper/internal/utils/browser"
	"github.com/haovoanh28/gai-webscraper/internal/utils/errutil"
)

func (s *scraper) ProcessDetailPage(detailUrl string) (*models.HoeInfo, error) {
	url := s.BaseURL + detailUrl

	id := utils.GetIDFromUrl(detailUrl)

	// Wait until content element is visible
	conn, err := browser.ConnectToPage(url, 2*time.Minute)
	if err != nil {
		return nil, errutil.WrapError("connect to page", err, url)
	}
	defer conn.Close()

	containerEle, err := browser.GetVisibleElement(conn.Root, detailPageSelectors.PageContainer)
	if err != nil {
		return nil, errutil.WrapError("get container element", err, url)
	}

	detailInfoTabEle, err := browser.GetVisibleElement(containerEle, detailPageSelectors.DetailInfoTab)
	if err != nil {
		return nil, errutil.WrapError("get detail info tab element", err, url)
	}

	hoeInfo := models.HoeInfo{
		OriginID: id,
		Url:      url,
	}

	hoeInfo.Name = browser.MustGetElementText(containerEle, detailPageSelectors.Name)

	hoeInfo.ImageUrl = browser.MustGetElementAttribute(containerEle, detailPageSelectors.ImageUrl, "src")

	price := browser.MustGetElementText(detailInfoTabEle, detailPageSelectors.Price)
	// Ex: "300 k" => "300k"
	hoeInfo.Price = strings.ReplaceAll(price, "\u00A0", "")
	// Ex: "1.000k" => "1000k"
	hoeInfo.Price = strings.ReplaceAll(hoeInfo.Price, ".", "")

	// Ex: "0123.456.789" -> "0123456789"
	phone := browser.MustGetElementText(detailInfoTabEle, detailPageSelectors.Phone)
	hoeInfo.Phone = strings.ReplaceAll(phone, ".", "")

	hoeInfo.Address = browser.MustGetElementText(detailInfoTabEle, detailPageSelectors.Address)
	hoeInfo.Provider = browser.MustGetElementText(detailInfoTabEle, detailPageSelectors.Author)
	hoeInfo.Status = browser.MustGetElementText(detailInfoTabEle, detailPageSelectors.Status)

	hoeInfo.BirthYear = browser.MustGetElementText(detailInfoTabEle, detailPageSelectors.BirthYear)
	hoeInfo.Height = browser.MustGetElementText(detailInfoTabEle, detailPageSelectors.Height)
	hoeInfo.Weight = browser.MustGetElementText(detailInfoTabEle, detailPageSelectors.Weight)
	hoeInfo.Country = browser.MustGetElementsText(detailInfoTabEle, detailPageSelectors.Country)
	hoeInfo.Service = browser.MustGetElementsText(detailInfoTabEle, detailPageSelectors.Service)
	hoeInfo.Duration = browser.MustGetElementText(detailInfoTabEle, detailPageSelectors.Duration)
	hoeInfo.WorkTime = browser.MustGetElementText(detailInfoTabEle, detailPageSelectors.WorkTime)

	// Get report urls
	var reports []*models.HoeReport
	reportTabEle, err := browser.GetVisibleElement(conn.Root, detailPageSelectors.ReportTab)
	if err != nil {
		return nil, errutil.WrapError("get report tab element", err, url)
	}

	if err := reportTabEle.Click(proto.InputMouseButtonLeft, 1); err != nil {
		return nil, errutil.WrapError("click report tab element", err, url)
	}

	if err := reportTabEle.WaitVisible(); err != nil {
		return nil, errutil.WrapError("wait report tab element visible", err, url)
	}

	reportTabContentEle, err := browser.GetVisibleElement(conn.Root, detailPageSelectors.ReportTabContent)
	if err != nil {
		return nil, errutil.WrapError("get report tab content element", err, url)
	}

	for {
		reportsEle, err := browser.GetMultipleElementsWithRetry(reportTabContentEle, detailPageSelectors.ReportList)
		if err != nil {
			return nil, errutil.WrapError("get report elements", err, url)
		}

		for _, reportEle := range reportsEle {
			reportUrl, err := browser.GetElementAttribute(reportEle, detailPageSelectors.ReportViewMoreBtn, "href")
			if err != nil {
				return nil, errutil.WrapError("get report url", err, url)
			}
			reports = append(reports, &models.HoeReport{
				ReportURL: reportUrl,
			})
		}

		goNextPageBtn, err := browser.GetVisibleElement(conn.Root, detailPageSelectors.ReportGoNextPageBtn)
		if err != nil {
			break
		} else {
			// Click go next page button
			if err := goNextPageBtn.Click(proto.InputMouseButtonLeft, 1); err != nil {
				return nil, errutil.WrapError("click go next page button", err, url)
			}

			time.Sleep(1 * time.Second)
		}
	}

	hoeInfo.Reports = reports
	return &hoeInfo, err
}

================
File: internal/scrapers/gaito/list.go
================
package gaito

import (
	"fmt"
	"time"

	"github.com/go-rod/rod/lib/proto"
	"github.com/haovoanh28/gai-webscraper/internal/utils/browser"
	"github.com/haovoanh28/gai-webscraper/internal/utils/errutil"
)

func (s *scraper) ProcessListPage() ([]string, error) {
	const (
		itemThreshold = 30
	)
	url := s.BaseURL + "/gai-goi/khu-vuc/Hồ%20Chí%20Minh/Quận%207"

	s.Logger.Info(fmt.Sprintf("Processing %s", url))

	conn, err := browser.ConnectToPage(url, 30*time.Second)
	if err != nil {
		return nil, errutil.WrapError("connect to page", err, url)
	}
	defer conn.Close()

	var urlList []string
	for {
		items, err := browser.GetMultipleElementsWithRetry(conn.Root, listPageSelectors.Items)
		if err != nil {
			return nil, errutil.WrapError("get list items", err, url)
		}

		// currentLength >= itemThreshold: enough items
		// currentLength == 0: for some reason, the query doesn't return any items (Ex: Cloudflare, ...)
		currentLength := len(items)
		if currentLength >= itemThreshold || currentLength == 0 {
			break
		}

		loadMoreBtn, err := browser.GetElementWithRetry(conn.Root, listPageSelectors.LoadMoreBtn)
		if err != nil {
			break
		}

		if err := loadMoreBtn.Click(proto.InputMouseButtonLeft, 1); err != nil {
			return nil, errutil.WrapError("click load more button", err, url)
		}

		if err := conn.Page.WaitElementsMoreThan(listPageSelectors.Items, currentLength); err != nil {
			return nil, errutil.WrapError("wait more items", err, url)
		}
	}

	elements, err := browser.GetMultipleElementsWithRetry(conn.Root, listPageSelectors.Items)
	if err != nil {
		return nil, errutil.WrapError("get final list items", err, url)
	}

	for _, elem := range elements {
		urlList = append(urlList, *elem.MustElement(listPageSelectors.ThumbnailUrl).MustAttribute("href"))
	}

	return urlList, nil
}

================
File: internal/scrapers/gaito/report.go
================
package gaito

// import (
// 	"fmt"
// 	"strconv"

// 	"github.com/go-rod/rod"
// 	"github.com/haovoanh28/gai-webscraper/internal/models"
// 	"github.com/haovoanh28/gai-webscraper/internal/utils"
// 	"github.com/haovoanh28/gai-webscraper/internal/utils/browser"
// )

// func ProcessReportPage(reportUrl string) models.HoeReportInfo {
// 	url := BaseUrl + reportUrl
// 	id := utils.GetIDFromUrl(reportUrl)

// 	reportInfo := models.HoeReportInfo{
// 		ID:        id,
// 		DetailUrl: reportUrl,
// 	}

// 	page := rod.New().MustConnect().MustPage(url).MustWaitStable()
// 	element := page.MustElement(`review-detail-cmp`).MustWaitVisible()
// 	defer page.Close()

// 	stars, err := page.Elements(`span[ng-model="data.review.score"] i.fa-heart[ng-repeat="r in range track by $index"]`)
// 	if err != nil {
// 		panic(fmt.Errorf(`failed to get stars: %v`, err))
// 	}
// 	reportInfo.Rating = strconv.Itoa(len(stars))

// 	reportInfo.Description = browser.GetElementText(element, `div[ng-switch-when="textarea"] span[ng-bind="elem.question.response"]`, id+"_report_description")

// 	// Process author
// 	authorSectionElement, err := page.Element(`div.ow_page_padding > div > div > div > div > div > div:nth-child(3) > div > div.col-md-4 > div:nth-child(2) > div > div.ow_user_list_data`)
// 	if err != nil {
// 		panic(fmt.Errorf(`failed to get author section: %v`, err))
// 	}
// 	authorUrlElement := authorSectionElement.MustElement(`a.ng-binding`)
// 	authorUrl := authorUrlElement.MustAttribute(`href`)
// 	reportInfo.Author = &models.Reporter{
// 		ID:   utils.GetIDFromUrl(*authorUrl),
// 		Name: authorUrlElement.MustText(),
// 		Url:  *authorUrl,
// 	}
// 	reportInfo.Time = browser.GetElementText(element, `div.ow_page_padding > div > div > div > div > div > div:nth-child(3) > div > div.col-md-8 > review-detail-cmp > div:nth-child(1) > em > small`, id+"_report_time")

// 	return reportInfo
// }

================
File: internal/scrapers/gaito/scraper.go
================
package gaito

import (
	"github.com/haovoanh28/gai-webscraper/internal/definitions"
)

type scraper struct {
	definitions.ScraperConfig
}

func NewScraper(config definitions.ScraperConfig) *scraper {
	return &scraper{
		config,
	}
}

================
File: internal/scrapers/gaito/selectors.go
================
package gaito

// ListPageSelectors contains all selectors used in list page scraping
type ListPageSelectors struct {
	Items        string
	LoadMoreBtn  string
	ThumbnailUrl string
}

type DetailPageSelectors struct {
	PageContainer  string
	DetailInfoTab  string
	DetailInfoCard string

	ReportTab           string
	ReportTabContent    string
	ReportList          string
	ReportViewMoreBtn   string
	ReportGoNextPageBtn string

	Name      string
	ImageUrl  string
	Price     string
	Phone     string
	Address   string
	Author    string
	Status    string
	BirthYear string
	Height    string
	Weight    string
	Country   string
	Service   string
	Duration  string
	WorkTime  string
}

var (
	listPageSelectors = ListPageSelectors{
		Items:        `div[ng-repeat="item in products"]`,
		LoadMoreBtn:  `body > div.container.seduction-container > div.knn_page_wrap > div.ow_page_padding > div > div > div > div > div > div:nth-child(3) > div:nth-child(4) > div > button`,
		ThumbnailUrl: `.thumbnail a`,
	}

	detailPageSelectors = DetailPageSelectors{
		PageContainer:  `.container.seduction-container .ow_page_container`,
		DetailInfoTab:  `.tab-content`,
		DetailInfoCard: `.jumbotron.ng-scope`,

		ReportTab:           `li[index="2"] a.nav-link`,
		ReportTabContent:    `product-review[ng-if="reviewTabLoaded"] div.panel-body`,
		ReportList:          `div[ng-repeat="review in reviews"]`,
		ReportViewMoreBtn:   `a.view_more_report`,
		ReportGoNextPageBtn: `product-review li.pagination-next:not(.disabled) a[ng-click]`,

		Name:      `div:nth-child(3) > div > h1`,
		ImageUrl:  `div:nth-child(3) > div > div:nth-child(3) > div > div > div > div.tab-pane.ng-scope.active > div.jumbotron.ng-scope > div > div.col-md-3.col-sm-4.media.escort_item_wrap > div > image-placeholder > img`,
		Price:     `.jumbotron .fa.fa-money + span`,
		Phone:     `.jumbotron .fa.fa-phone + a`,
		Address:   `.jumbotron .fa.fa-map-marker + a`,
		Author:    `.jumbotron .fa.fa-user + a`,
		Status:    `.jumbotron .fa.fa-file-o + span`,
		BirthYear: `product-attribute table > tbody > tr:nth-child(3) > td:nth-child(2) > attribute-dob-box > div > div`,
		Height:    `product-attribute table > tbody > tr:nth-child(4) > td:nth-child(2) > attribute-number-box .ng-scope`,
		Weight:    `product-attribute table > tbody > tr:nth-child(5) > td:nth-child(2) > attribute-number-box .ng-scope`,
		Country:   `product-attribute table > tbody > tr:nth-child(9) > td:nth-child(2) > attribute-radio-box span span[ng-repeat="item in attributeDto.settings.values"]`,
		Service:   `product-attribute table > tbody > tr:nth-child(12) > td:nth-child(2) > attribute-choices-box span span[ng-repeat="item in attributeDto.settings.values"]`,
		Duration:  `product-attribute table > tbody > tr:nth-child(15) > td:nth-child(2) > attribute-text-box span`,
		WorkTime:  `product-attribute table > tbody > tr:nth-child(16) > td:nth-child(2) > attribute-text-box span`,
	}
)

================
File: internal/service/hoe.go
================
package service

import (
	"github.com/haovoanh28/gai-webscraper/internal/models"
	"github.com/haovoanh28/gai-webscraper/internal/repository"
	"github.com/haovoanh28/gai-webscraper/internal/utils/logutil"
)

type HoeService struct {
	repo   repository.HoeRepository
	logger *logutil.Logger
}

func NewHoeService(repo repository.HoeRepository, logger *logutil.Logger) *HoeService {
	return &HoeService{repo: repo, logger: logger}
}

func (s *HoeService) ProcessHoe(hoe *models.HoeInfo) error {
	s.logger.Info("Processing hoe: ", hoe.Name)
	return nil
}

================
File: internal/utils/browser/connect.go
================
package browser

import (
	"crypto/md5"
	"fmt"
	"time"

	"github.com/go-rod/rod"
	"github.com/go-rod/stealth"
)

type BrowserConnection struct {
	Browser *rod.Browser
	Page    *rod.Page
	Root    *rod.Element
}

func (c *BrowserConnection) Close() {
	if c.Browser != nil {
		c.Browser.Close()
	}
	if c.Page != nil {
		c.Page.Close()
	}
}

func ConnectToPage(url string, timeout time.Duration) (*BrowserConnection, error) {
	rodBrowser := rod.New().Timeout(timeout)
	if err := rodBrowser.Connect(); err != nil {
		return nil, err
	}

	// stealth must be used because of Cloudflare
	// But it only works sometimes
	fmt.Printf("js: %x\n\n", md5.Sum([]byte(stealth.JS)))
	page, err := stealth.Page(rodBrowser)
	if err != nil {
		return nil, err
	}

	if err := page.Navigate(url); err != nil {
		return nil, err
	}

	if err := page.WaitStable(time.Duration(30)); err != nil {
		return nil, err
	}

	root := page.MustElement("html")
	return &BrowserConnection{Browser: rodBrowser, Page: page, Root: root}, nil
}

================
File: internal/utils/browser/element.go
================
package browser

import (
	"fmt"
	"strings"

	"github.com/go-rod/rod"
)

func GetVisibleElement(rodElement *rod.Element, selector string) (*rod.Element, error) {
	element, err := GetElementWithRetry(rodElement, selector)
	if err != nil {
		return nil, err
	}

	if err = element.WaitVisible(); err != nil {
		return nil, err
	}

	return element, nil
}

func GetElementWithRetry(rodElement *rod.Element, selector string) (*rod.Element, error) {
	return retryRodElement(func() (*rod.Element, error) {
		return rodElement.Element(selector)
	})
}

func GetMultipleElementsWithRetry(rodElement *rod.Element, selector string) ([]*rod.Element, error) {
	elements, err := retryRodElement(func() ([]*rod.Element, error) {
		return rodElement.Elements(selector)
	})

	if err != nil {
		return nil, err
	}

	return elements, nil
}

func GetElementText(rodElement *rod.Element, selector string) (string, error) {
	element, err := GetVisibleElement(rodElement, selector)
	if err != nil {
		return "", err
	}

	text, err := element.Text()
	if err != nil {
		return "", err
	}

	return strings.TrimSpace(text), nil
}

func GetElementAttribute(rodElement *rod.Element, selector string, attributeName string) (string, error) {
	element, err := GetVisibleElement(rodElement, selector)
	if err != nil {
		return "", err
	}

	attribute, err := element.Attribute(attributeName)
	if err != nil {
		return "", err
	}

	if attribute == nil {
		return "", nil
	}

	return *attribute, nil
}

func GetElementsText(rodElement *rod.Element, selector string) (string, error) {
	elements, err := GetMultipleElementsWithRetry(rodElement, selector)
	if err != nil {
		return "", err
	}

	var texts []string
	for _, element := range elements {
		text, err := element.Text()
		if err != nil {
			return "", err
		}

		text = strings.TrimSpace(text)
		if text != "" {
			texts = append(texts, text)
		}
	}

	return strings.Join(texts, ", "), nil
}

// MUST FUNCTIONS
// Thêm mấy hàm Must để YOLO
func MustGetVisibleElement(rodElement *rod.Element, selector string) *rod.Element {
	element, err := GetVisibleElement(rodElement, selector)
	if err != nil {
		panic(fmt.Errorf("selector '%s': %w", selector, err))
	}
	return element
}

func MustGetElementText(rodElement *rod.Element, selector string) string {
	text, err := GetElementText(rodElement, selector)
	if err != nil {
		panic(fmt.Errorf("cannot get text from selector '%s': %w", selector, err))
	}
	return text
}

func MustGetElementsText(rodElement *rod.Element, selector string) string {
	text, err := GetElementsText(rodElement, selector)
	if err != nil {
		panic(fmt.Errorf("cannot get text from selector '%s': %w", selector, err))
	}
	return text
}

func MustGetElementAttribute(rodElement *rod.Element, selector string, attributeName string) string {
	attr, err := GetElementAttribute(rodElement, selector, attributeName)
	if err != nil {
		panic(fmt.Errorf("cannot get attribute '%s' from selector '%s': %w",
			attributeName, selector, err))
	}
	return attr
}

================
File: internal/utils/browser/rate_limit.go
================
package browser

import "time"

type RateLimiter struct {
	interval time.Duration
	ticker   *time.Ticker
}

func NewRateLimiter(requestsPerSecond float64) *RateLimiter {
	interval := time.Duration(1000/requestsPerSecond) * time.Millisecond
	return &RateLimiter{
		interval: interval,
		ticker:   time.NewTicker(interval),
	}
}

func (r *RateLimiter) Wait() {
	<-r.ticker.C
}

================
File: internal/utils/browser/retry.go
================
package browser

import (
	"time"

	"github.com/go-rod/rod"
)

func retryRodElement[T any](operation func() (T, error)) (T, error) {
	maxAttempts := 20
	interval := 500 * time.Millisecond

	var lastErr error
	for attempt := 0; attempt < maxAttempts; attempt++ {
		result, err := operation()
		if err == nil {
			if slice, ok := any(result).([]*rod.Element); ok { // Check for multiple elements
				if len(slice) > 0 {
					return result, nil
				}
			} else if elem, ok := any(result).(*rod.Element); ok { // Check for single element
				if elem != nil {
					if visible, _ := elem.Visible(); visible {
						return result, nil
					}
				}
			}
		}
		lastErr = err
		time.Sleep(interval)
	}

	var zero T
	return zero, lastErr
}

================
File: internal/utils/common.go
================
package utils

import (
	"fmt"
	"regexp"
	"strings"
)

func GetIDFromUrl(url string) string {
	url = strings.TrimSuffix(url, "/")

	// Pattern 1: "/x/y/id/z" - extract ID between segments
	re1 := regexp.MustCompile(`/([^/]+)/[^/]+$`)
	if match := re1.FindStringSubmatch(url); len(match) >= 2 {
		return match[1]
	}

	// Pattern 2: "/a/id" - extract ID at the end
	re2 := regexp.MustCompile(`/([^/]+)$`)
	if match := re2.FindStringSubmatch(url); len(match) >= 2 {
		return match[1]
	}

	return ""
}

func HandleError(err error, operation string, fieldName string) {
	if err != nil {
		panic(fmt.Errorf(`failed to %s "%s": %v`, operation, fieldName, err))
	}
}

================
File: internal/utils/errutil/handler.go
================
package errutil

import (
	"runtime"
	"strings"
)

type ScrapeError struct {
	Op     string // Operation being performed
	Target string // Target being scraped (URL, selector, etc)
	Err    error  // Original error
	File   string // Source file where error occurred
	Line   int    // Line number where error occurred
}

func (se *ScrapeError) Error() string {
	parts := []string{se.Op}

	if se.Target != "" {
		parts = append(parts, "target: "+se.Target)
	}
	if se.Err != nil {
		parts = append(parts, "error: "+se.Err.Error())
	}

	return strings.Join(parts, " - ")
}

func WrapError(op string, err error, target string) error {
	if err == nil {
		return nil
	}

	_, file, line, _ := runtime.Caller(1)

	serr := &ScrapeError{
		Op:     op,
		Target: target,
		Err:    err,
		File:   file,
		Line:   line,
	}

	return serr
}

================
File: internal/utils/logutil/handler.go
================
package logutil

import (
	"log"
	"os"
)

type Logger struct {
	logger   *log.Logger
	minLevel LogLevel
}

func NewLogger(minLevel LogLevel) *Logger {
	return &Logger{
		logger:   log.Default(),
		minLevel: minLevel,
	}
}

func (l *Logger) Log(level LogLevel, msg string, args ...interface{}) {
	if level >= l.minLevel {
		l.logger.Printf("["+level.String()+"] "+msg, args...)
	}
}

func (l *Logger) Debug(msg string, args ...interface{}) {
	l.Log(DEBUG, msg, args...)
}

func (l *Logger) Info(msg string, args ...interface{}) {
	l.Log(INFO, msg, args...)
}

func (l *Logger) Warn(msg string, args ...interface{}) {
	l.Log(WARN, msg, args...)
}

func (l *Logger) Error(msg string, args ...interface{}) {
	l.Log(ERROR, msg, args...)
}

func (l *Logger) Fatal(msg string, args ...interface{}) {
	l.Log(FATAL, msg, args...)
	// panic(msg) // or os.Exit(1) depending on your needs
	os.Exit(1)
}

================
File: internal/utils/logutil/level.go
================
package logutil

import (
	"fmt"
	"strings"
)

type LogLevel int

const (
	DEBUG LogLevel = iota
	INFO
	WARN
	ERROR
	FATAL
)

func (l LogLevel) String() string {
	switch l {
	case DEBUG:
		return "DEBUG"
	case INFO:
		return "INFO"
	case WARN:
		return "WARN"
	case ERROR:
		return "ERROR"
	case FATAL:
		return "FATAL"
	default:
		return "UNKNOWN"
	}
}

func ParseLogLevel(level string) (LogLevel, error) {
	switch strings.ToUpper(level) {
	case "DEBUG":
		return DEBUG, nil
	case "INFO":
		return INFO, nil
	case "WARN":
		return WARN, nil
	case "ERROR":
		return ERROR, nil
	case "FATAL":
		return FATAL, nil
	default:
		return INFO, fmt.Errorf("unknown log level: %s", level)
	}
}

================
File: internal/utils/setuputil/setup.go
================
package setuputil

import (
	"flag"
	"fmt"
	"log"
	"os"

	"github.com/haovoanh28/gai-webscraper/internal/db"
	"github.com/haovoanh28/gai-webscraper/internal/definitions"
	"github.com/haovoanh28/gai-webscraper/internal/interfaces"
	"github.com/haovoanh28/gai-webscraper/internal/repository"
	"github.com/haovoanh28/gai-webscraper/internal/scrapers"
	"github.com/haovoanh28/gai-webscraper/internal/service"
	"github.com/haovoanh28/gai-webscraper/internal/utils/errutil"
	"github.com/haovoanh28/gai-webscraper/internal/utils/logutil"
)

type AppContext struct {
	Scraper    interfaces.Scraper
	Logger     *logutil.Logger
	HoeService *service.HoeService
}

func InitLogger() *logutil.Logger {
	log.SetFlags(log.LstdFlags)

	logLevelStr := os.Getenv("LOG_LEVEL")
	logLevel, err := logutil.ParseLogLevel(logLevelStr)
	if err != nil {
		log.Printf("Invalid log level '%s', defaulting to INFO", logLevelStr)
		logLevel = logutil.INFO
	}

	return logutil.NewLogger(logLevel)
}

func CreateAppContext() (*AppContext, error) {
	// Get site from cmd options
	site := flag.String("site", "", "The site to scrape")
	flag.Parse()

	siteType := definitions.SiteType(*site)
	baseURL, ok := definitions.SiteConfigs[siteType]
	if !ok {
		return nil, fmt.Errorf("unknown site: %s", *site)
	}

	logger := InitLogger()
	baseConfig := definitions.ScraperConfig{
		Site:              siteType,
		BaseURL:           baseURL,
		RequestsPerSecond: 1.0,
		Logger:            logger,
	}

	scraper := scrapers.CreateScraper(baseConfig)

	dbConfig := db.NewConfig()
	dbo, err := db.GetDB(dbConfig)
	if err != nil {
		return nil, errutil.WrapError("failed to connect to database", err, "")
	}
	hoeRepo := repository.NewHoeRepository(dbo)
	hoeService := service.NewHoeService(hoeRepo, logger)

	return &AppContext{
		Scraper:    scraper,
		Logger:     logger,
		HoeService: hoeService,
	}, nil
}
