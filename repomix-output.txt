This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-24T13:34:54.413Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
cmd/
  detail/
    main.go
  list/
    main.go
  migrate/
    main.go
internal/
  definitions/
    config.go
    hoe.go
  dto/
    hoe_dto.go
  infrastructure/
    browser/
      roddriver/
        browser.go
        element.go
        page.go
        retry.go
      connect.go
      factory.go
      rate_limit.go
    database/
      connection.go
      migrate.go
      seed_default_data.go
      types.go
    interfaces/
      browser.go
  interfaces/
    scraper.go
  models/
    city.go
    district.go
    hoe_profile.go
    hoe_report.go
    hoe.go
    reporter.go
    site.go
    street.go
    working_history.go
  repository/
    hoe.go
    location.go
    site.go
    working_history.go
  scrapers/
    gaito/
      detail.go
      list.go
      report.go
      scraper.go
      selectors.go
    factory.go
  service/
    hoe.go
    mapper.go
    validate.go
  utils/
    errutil/
      handler.go
    logutil/
      handler.go
      level.go
    setuputil/
      setup.go
    common.go
.gitignore
docker-compose.yml
go.mod
go.sum

================================================================
Repository Files
================================================================

================
File: cmd/detail/main.go
================
package main

import (
	"github.com/haovoanh28/gai-webscraper/internal/utils/setuputil"
)

func main() {
	appContext, err := setuputil.CreateAppContext()
	if err != nil {
		panic(err)
	}

	// Example url
	url := "/gai-goi/chi-tiet/56042/hot-girl-diep-anhmat-xinh-nguc-dep-bu-cu-dieu-luyen"

	err = appContext.HoeService.ProcessDetailPage(url)
	if err != nil {
		appContext.Logger.Fatal(err.Error())
	}
}

================
File: cmd/list/main.go
================
package main

import (
	"github.com/haovoanh28/gai-webscraper/internal/utils/setuputil"
)

func main() {
	appContext, err := setuputil.CreateAppContext()
	if err != nil {
		panic(err)
	}

	err = appContext.HoeService.ProcessListPage()
	if err != nil {
		appContext.Logger.Fatal(err.Error())
	}
}

================
File: cmd/migrate/main.go
================
package main

import "github.com/haovoanh28/gai-webscraper/internal/infrastructure/database"

func main() {
	db, err := database.InitDB()
	if err != nil {
		panic(err)
	}

	if err := database.Migrate(db); err != nil {
		panic(err)
	}

	if err := database.SeedDefaultData(db); err != nil {
		panic(err)
	}
}

================
File: internal/definitions/config.go
================
package definitions

import "github.com/haovoanh28/gai-webscraper/internal/utils/logutil"

type ScraperConfig struct {
	SiteID            uint
	SiteName          string
	BaseURL           string
	RequestsPerSecond float64
	Logger            *logutil.Logger
}

================
File: internal/definitions/hoe.go
================
package definitions

import (
	"database/sql/driver"
	"fmt"
)

type HoeStatus string

type ParsedAddress struct {
	Street   string
	District string
}

const (
	HoeStatusActive   HoeStatus = "active"
	HoeStatusInactive HoeStatus = "inactive"
	HoeStatusUnknown  HoeStatus = "unknown"
)

// For database serialization
func (s HoeStatus) Value() (driver.Value, error) {
	return string(s), nil
}

// For database deserialization
func (s *HoeStatus) Scan(value interface{}) error {
	if value == nil {
		*s = HoeStatusUnknown
		return nil
	}

	str, ok := value.(string)
	if !ok {
		return fmt.Errorf("invalid status value: %v", value)
	}

	*s = HoeStatus(str)
	return nil
}

================
File: internal/dto/hoe_dto.go
================
package dto

type RawHoeData struct {
	SiteID   uint
	OriginID string
	Url      string

	// All scraped fields without transformation
	Name      string
	ImageUrl  string
	Price     string
	Phone     string
	Address   string
	Provider  string
	Status    string
	BirthYear string
	Height    string
	Weight    string
	Country   string
	Service   string
	Duration  string
	WorkTime  string
}

================
File: internal/infrastructure/browser/roddriver/browser.go
================
package roddriver

import (
	"time"

	"github.com/go-rod/rod"
	"github.com/go-rod/stealth"
	"github.com/haovoanh28/gai-webscraper/internal/infrastructure/interfaces"
)

type rodBrowser struct {
	browser *rod.Browser
}

func (rb *rodBrowser) Connect() error {
	if err := rb.browser.Connect(); err != nil {
		return err
	}

	return nil
}

func (rb *rodBrowser) Close() {
	rb.browser.Close()
}

func (rb *rodBrowser) CreatePage() (interfaces.Page, error) {
	page, err := stealth.Page(rb.browser)
	if err != nil {
		return nil, err
	}

	return &rodPage{page: page}, nil
}

// Return rodBrowser, if later uses another library, consider using a factory pattern
func NewBrowser(timeout time.Duration) interfaces.Browser {
	return &rodBrowser{browser: rod.New().Timeout(timeout)}
}

================
File: internal/infrastructure/browser/roddriver/element.go
================
package roddriver

import (
	"strings"

	"github.com/go-rod/rod"
	"github.com/go-rod/rod/lib/proto"
	"github.com/haovoanh28/gai-webscraper/internal/infrastructure/interfaces"
)

type rodElement struct {
	element *rod.Element
}

// *Return rodElement, if later uses another library, consider using a factory pattern
func NewElement(element *rod.Element) interfaces.Element {
	return &rodElement{element: element}
}

func (re *rodElement) getElementWithRetry(selector string) (*rod.Element, error) {
	return retryRodElement(func() (*rod.Element, error) {
		return re.element.Element(selector)
	})
}

func (re *rodElement) getMultipleElementsWithRetry(selector string) ([]*rod.Element, error) {
	return retryRodElement(func() ([]*rod.Element, error) {
		return re.element.Elements(selector)
	})
}

// Implementing Element interface
func (re *rodElement) Find(selector string) (interfaces.Element, error) {
	elem, err := re.getElementWithRetry(selector)
	if err != nil {
		return nil, err
	}
	return NewElement(elem), nil
}

func (re *rodElement) FindAll(selector string) ([]interfaces.Element, error) {
	elems, err := re.getMultipleElementsWithRetry(selector)
	if err != nil {
		return nil, err
	}

	elements := make([]interfaces.Element, len(elems))
	for i, elem := range elems {
		elements[i] = NewElement(elem)
	}
	return elements, nil
}

func (re *rodElement) GetText() (string, error) {
	text, err := re.element.Text()
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(text), nil
}

func (re *rodElement) GetAttribute(name string) (string, error) {
	attr, err := re.element.Attribute(name)
	if err != nil {
		return "", err
	}
	if attr == nil {
		return "", nil
	}
	return *attr, nil
}

func (re *rodElement) Click() error {
	return re.element.Click(proto.InputMouseButtonLeft, 1)
}

func (re *rodElement) WaitVisible() error {
	return re.element.WaitVisible()
}

// Must versions that panic on error
func (re *rodElement) MustFind(selector string) interfaces.Element {
	elem, err := re.Find(selector)
	if err != nil {
		panic(err)
	}
	return elem
}

func (re *rodElement) MustGetText() string {
	text, err := re.GetText()
	if err != nil {
		panic(err)
	}
	return text
}

func (re *rodElement) MustGetAttribute(name string) string {
	attr, err := re.GetAttribute(name)
	if err != nil {
		panic(err)
	}
	return attr
}

================
File: internal/infrastructure/browser/roddriver/page.go
================
package roddriver

import (
	"time"

	"github.com/go-rod/rod"
	"github.com/haovoanh28/gai-webscraper/internal/infrastructure/interfaces"
)

type rodPage struct {
	page *rod.Page
}

func (rp *rodPage) Navigate(url string) error {
	return rp.page.Navigate(url)
}

func (rp *rodPage) WaitStable(timeout time.Duration) error {
	return rp.page.WaitStable(timeout)
}

func (rp *rodPage) GetRootElement() interfaces.Element {
	return NewElement(rp.page.MustElement("html"))
}

func (rp *rodPage) Close() {
	rp.page.Close()
}

func (rp *rodPage) WaitElementsMoreThan(selector string, count int) error {
	return rp.page.WaitElementsMoreThan(selector, count)
}

================
File: internal/infrastructure/browser/roddriver/retry.go
================
package roddriver

import (
	"time"

	"github.com/go-rod/rod"
)

func retryRodElement[T any](operation func() (T, error)) (T, error) {
	maxAttempts := 20
	interval := 500 * time.Millisecond

	var lastErr error
	for attempt := 0; attempt < maxAttempts; attempt++ {
		result, err := operation()
		if err == nil {
			if slice, ok := any(result).([]*rod.Element); ok { // Check for multiple elements
				if len(slice) > 0 {
					return result, nil
				}
			} else if elem, ok := any(result).(*rod.Element); ok { // Check for single element
				if elem != nil {
					if visible, _ := elem.Visible(); visible {
						return result, nil
					}
				}
			}
		}
		lastErr = err
		time.Sleep(interval)
	}

	var zero T
	return zero, lastErr
}

================
File: internal/infrastructure/browser/connect.go
================
package browser

import (
	"time"

	"github.com/haovoanh28/gai-webscraper/internal/infrastructure/interfaces"
)

type Connection struct {
	Browser interfaces.Browser
	Page    interfaces.Page
	Root    interfaces.Element
}

func (c *Connection) Close() {
	if c.Browser != nil {
		c.Browser.Close()
	}
	if c.Page != nil {
		c.Page.Close()
	}
}

func ConnectToPage(url string, timeout time.Duration) (*Connection, error) {
	browser := NewBrowser(RodDriver, timeout)
	if err := browser.Connect(); err != nil {
		return nil, err
	}

	page, err := browser.CreatePage()
	if err != nil {
		return nil, err
	}

	if err := page.Navigate(url); err != nil {
		return nil, err
	}

	if err := page.WaitStable(time.Duration(30)); err != nil {
		return nil, err
	}

	root := page.GetRootElement()
	if err := root.WaitVisible(); err != nil {
		page.Close()
		browser.Close()
		return nil, err
	}

	return &Connection{Browser: browser, Page: page, Root: root}, nil
}

================
File: internal/infrastructure/browser/factory.go
================
package browser

import (
	"time"

	"github.com/haovoanh28/gai-webscraper/internal/infrastructure/browser/roddriver"
	"github.com/haovoanh28/gai-webscraper/internal/infrastructure/interfaces"
)

type DriverType string

const (
	RodDriver DriverType = "rod"
	// Future drivers can be added here
	// SeleniumDriver DriverType = "selenium"
)

// NewBrowser creates a new browser instance based on the driver type
func NewBrowser(driverType DriverType, timeout time.Duration) interfaces.Browser {
	switch driverType {
	case RodDriver:
		return roddriver.NewBrowser(timeout)
	default:
		// For now, default to Rod
		return roddriver.NewBrowser(timeout)
	}
}

================
File: internal/infrastructure/browser/rate_limit.go
================
package browser

import "time"

type RateLimiter struct {
	interval time.Duration
	ticker   *time.Ticker
}

func NewRateLimiter(requestsPerSecond float64) *RateLimiter {
	interval := time.Duration(1000/requestsPerSecond) * time.Millisecond
	return &RateLimiter{
		interval: interval,
		ticker:   time.NewTicker(interval),
	}
}

func (r *RateLimiter) Wait() {
	<-r.ticker.C
}

================
File: internal/infrastructure/database/connection.go
================
package database

import (
	"fmt"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

func InitDB() (*gorm.DB, error) {
	cfg := NewConfig()
	db, err := GetDB(cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %v", err)
	}

	return db, nil
}

func NewConfig() *DBConfig {
	return &DBConfig{
		Host:     "127.0.0.1",
		Port:     "3306",
		User:     "hao",
		Password: "password123",
		DBName:   "gai-scraper",
	}
}

func (c *DBConfig) BuildConnectionString() string {
	return fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
		c.User, c.Password, c.Host, c.Port, c.DBName)
}

func GetDB(cfg *DBConfig) (*gorm.DB, error) {
	db, err := gorm.Open(mysql.Open(cfg.BuildConnectionString()), &gorm.Config{})
	if err != nil {
		return nil, err
	}

	return db, nil
}

func CloseDB(db *gorm.DB) error {
	sqlDB, err := db.DB()
	if err != nil {
		return err
	}

	return sqlDB.Close()
}

================
File: internal/infrastructure/database/migrate.go
================
package database

import (
	"fmt"

	"github.com/haovoanh28/gai-webscraper/internal/models"
	"gorm.io/gorm"
)

func Migrate(db *gorm.DB) error {
	_models := []interface{}{
		&models.Site{},
		&models.City{},
		&models.District{},
		&models.Street{},
		&models.HoeInfo{},
		&models.HoeReport{},
		&models.WorkingHistory{},
	}

	for _, model := range _models {
		if err := db.AutoMigrate(model); err != nil {
			return fmt.Errorf("failed to migrate %T: %v", model, err)
		}
	}

	return nil
}

================
File: internal/infrastructure/database/seed_default_data.go
================
package database

import (
	"fmt"

	"github.com/haovoanh28/gai-webscraper/internal/models"
	"gorm.io/gorm"
)

func SeedDefaultData(db *gorm.DB) error {
	if err := seedSites(db); err != nil {
		return err
	}

	if err := seedCities(db); err != nil {
		return err
	}

	return nil
}

func seedSites(db *gorm.DB) error {
	sites := []models.Site{
		{
			Name:      "gaito",
			BaseURL:   "https://gaito.so",
			IsExpired: false,
		},
		{
			Name:      "gaigu",
			BaseURL:   "https://gaigu31.tv",
			IsExpired: false,
		},
	}

	for _, site := range sites {
		result := db.Where(models.Site{Name: site.Name}).
			FirstOrCreate(&site)
		if result.Error != nil {
			return result.Error
		}
	}

	return nil
}

func seedCities(db *gorm.DB) error {
	cities := []models.City{
		{
			Name: "Hồ Chí Minh",
			Code: "HCM",
			Districts: []models.District{
				{Name: "Quận 1", ShortName: "Quận 1", Code: "Q1"},
				{Name: "Quận 2", ShortName: "Quận 2", Code: "Q2"},
				{Name: "Quận 3", ShortName: "Quận 3", Code: "Q3"},
				{Name: "Quận 4", ShortName: "Quận 4", Code: "Q4"},
				{Name: "Quận 5", ShortName: "Quận 5", Code: "Q5"},
				{Name: "Quận 6", ShortName: "Quận 6", Code: "Q6"},
				{Name: "Quận 7", ShortName: "Quận 7", Code: "Q7"},
				{Name: "Quận 8", ShortName: "Quận 8", Code: "Q8"},
				{Name: "Quận 9", ShortName: "Quận 9", Code: "Q9"},
				{Name: "Quận 10", ShortName: "Quận 10", Code: "Q10"},
				{Name: "Quận 11", ShortName: "Quận 11", Code: "Q11"},
				{Name: "Quận 12", ShortName: "Quận 12", Code: "Q12"},
				{Name: "Quận Bình Tân", ShortName: "Bình Tân", Code: "BTN"},
				{Name: "Quận Bình Thạnh", ShortName: "Bình Thạnh", Code: "BTH"},
				{Name: "Quận Bình Chánh", ShortName: "Bình Chánh", Code: "BCH"},
				{Name: "Quận Gò Vấp", ShortName: "Gò Vấp", Code: "GV"},
				{Name: "Quận Phú Nhuận", ShortName: "Phú Nhuận", Code: "PN"},
				{Name: "Quận Tân Bình", ShortName: "Tân Bình", Code: "TB"},
				{Name: "Quận Tân Phú", ShortName: "Tân Phú", Code: "TP"},
				{Name: "Quận Thủ Đức", ShortName: "Thủ Đức", Code: "TD"},
			},
		},
		{
			Name: "Hà Nội",
			Code: "HN",
			Districts: []models.District{
				{Name: "Quận Ba Đình", ShortName: "Ba Đình", Code: "BD"},
				{Name: "Quận Hoàn Kiếm", ShortName: "Hoàn Kiếm", Code: "HK"},
				{Name: "Quận Hai Bà Trưng", ShortName: "Hai Bà Trưng", Code: "HBT"},
				{Name: "Quận Đống Đa", ShortName: "Đống Đa", Code: "DD"},
				{Name: "Quận Tây Hồ", ShortName: "Tây Hồ", Code: "TH"},
				{Name: "Quận Cầu Giấy", ShortName: "Cầu Giấy", Code: "CG"},
				{Name: "Quận Thanh Xuân", ShortName: "Thanh Xuân", Code: "TX"},
				{Name: "Quận Hoàng Mai", ShortName: "Hoàng Mai", Code: "HM"},
				{Name: "Quận Long Biên", ShortName: "Long Biên", Code: "LB"},
				{Name: "Quận Nam Từ Liêm", ShortName: "Nam Từ Liêm", Code: "NTL"},
				{Name: "Quận Bắc Từ Liêm", ShortName: "Bắc Từ Liêm", Code: "BTL"},
				{Name: "Quận Hà Đông", ShortName: "Hà Đông", Code: "HD"},
			},
		},
	}

	for _, city := range cities {
		var existingCity models.City
		result := db.Where(models.City{Name: city.Name}).First(&existingCity)

		if result.Error != nil {
			// City doesn't exist, create new city with provinces
			if err := db.Create(&city).Error; err != nil {
				return fmt.Errorf("failed to create city %s: %v", city.Name, err)
			}
		} else {
			// City exists, check and create missing provinces
			for _, province := range city.Districts {
				province.CityID = existingCity.ID
				result := db.Where(models.District{
					Name:   province.Name,
					CityID: existingCity.ID,
				}).FirstOrCreate(&province)

				if result.Error != nil {
					return fmt.Errorf("failed to create province %s: %v", province.Name, result.Error)
				}
			}
		}
	}

	return nil
}

================
File: internal/infrastructure/database/types.go
================
package database

type DBConfig struct {
	Host     string
	Port     string
	User     string
	Password string
	DBName   string
}

================
File: internal/infrastructure/interfaces/browser.go
================
package interfaces

import "time"

type Browser interface {
	Connect() error
	Close()
	CreatePage() (Page, error)
}

type Page interface {
	Navigate(url string) error
	WaitStable(timeout time.Duration) error
	WaitElementsMoreThan(selector string, count int) error
	GetRootElement() Element
	Close()
}

type Element interface {
	Find(selector string) (Element, error)
	FindAll(selector string) ([]Element, error)
	GetText() (string, error)
	GetAttribute(name string) (string, error)
	Click() error
	WaitVisible() error
	MustFind(selector string) Element
	MustGetText() string
	MustGetAttribute(name string) string
}

================
File: internal/interfaces/scraper.go
================
package interfaces

import (
	"github.com/haovoanh28/gai-webscraper/internal/dto"
)

type Scraper interface {
	GetDetailURLs() ([]string, error)
	GetRawHoeData(url string) (*dto.RawHoeData, error)
}

================
File: internal/models/city.go
================
package models

type City struct {
	ID        uint       `gorm:"primaryKey"`
	Name      string     `gorm:"column:name"`
	Code      string     `gorm:"column:code"`
	Districts []District `gorm:"foreignKey:CityID;references:ID;constraint:OnDelete:CASCADE"`
}

func (City) TableName() string {
	return "cities"
}

================
File: internal/models/district.go
================
package models

type District struct {
	ID        uint   `gorm:"primaryKey"`
	Name      string `gorm:"column:name"`
	ShortName string `gorm:"column:short_name"`
	Code      string `gorm:"column:code"`
	CityID    uint   `gorm:"column:city_id;index"`

	City    City     `gorm:"foreignKey:CityID;"`
	Streets []Street `gorm:"foreignKey:DistrictID;references:ID;constraint:OnDelete:CASCADE"`
}

func (District) TableName() string {
	return "districts"
}

================
File: internal/models/hoe_profile.go
================
package models

import (
	"time"

	"github.com/haovoanh28/gai-webscraper/internal/definitions"
)

type HoeProfile struct {
	ID        uint                  `gorm:"primaryKey"`
	HoeID     uint                  `gorm:"column:hoe_id"`
	SiteID    uint                  `gorm:"column:site_id;index"`
	OriginID  string                `gorm:"column:origin_id"`
	Url       string                `gorm:"column:url"`
	ImageUrl  string                `gorm:"column:image_url"`
	Price     string                `gorm:"column:price"`
	Area      string                `gorm:"column:area"`
	Provider  string                `gorm:"column:provider"`
	Status    definitions.HoeStatus `gorm:"column:status;type:enum('active','inactive','unknown')"`
	Service   string                `gorm:"column:service"`
	Duration  string                `gorm:"column:duration"`
	WorkTime  string                `gorm:"column:work_time"`
	CreatedAt time.Time             `gorm:"column:created_at"`
	UpdatedAt time.Time             `gorm:"column:updated_at"`

	Hoe     HoeInfo     `gorm:"foreignKey:HoeID"`
	Site    Site        `gorm:"foreignKey:SiteID"`
	Reports []HoeReport `gorm:"foreignKey:HoeProfileID"`
}

func (p *HoeProfile) TableName() string {
	return "hoe_profiles"
}

================
File: internal/models/hoe_report.go
================
package models

import "time"

type HoeReport struct {
	ID           uint      `gorm:"primaryKey"`
	HoeProfileID uint      `gorm:"column:hoe_profile_id"`
	ReportURL    string    `gorm:"column:report_url"`
	CreatedAt    time.Time `gorm:"column:created_at"`
	UpdatedAt    time.Time `gorm:"column:updated_at"`

	Profile HoeProfile `gorm:"foreignKey:HoeProfileID"`
}

func (HoeReport) TableName() string {
	return "hoe_reports"
}

================
File: internal/models/hoe.go
================
package models

import (
	"fmt"
	"time"
)

type HoeInfo struct {
	ID            uint      `gorm:"primaryKey"`
	Name          string    `gorm:"column:name"`
	Phone         string    `gorm:"column:phone;index;unique"`
	BirthYear     string    `gorm:"column:birth_year"`
	Height        string    `gorm:"column:height"`
	Weight        string    `gorm:"column:weight"`
	Country       string    `gorm:"column:country"`
	LastScrapedAt time.Time `gorm:"column:last_scraped_at"`
	CreatedAt     time.Time `gorm:"column:created_at"`
	UpdatedAt     time.Time `gorm:"column:updated_at"`

	// Site-specific profiles
	Profiles []HoeProfile `gorm:"foreignKey:HoeID;references:ID"`
	// Working histories
	WorkingHistories []WorkingHistory `gorm:"foreignKey:HoeID;references:ID"`
}

func (*HoeInfo) TableName() string {
	return "hoes"
}

func (h *HoeInfo) GetProfileBySite(siteID uint) *HoeProfile {
	for i := range h.Profiles {
		if h.Profiles[i].SiteID == siteID {
			return &h.Profiles[i]
		}
	}

	return nil
}

func (h *HoeInfo) GetCurrentScrapingProfile() (*HoeProfile, error) {
	if len(h.Profiles) == 0 {
		return nil, fmt.Errorf("hoe has no profile")
	}

	// Why Profiles[0] ?
	// Because the first profile is the one that is currently being scraped
	return &h.Profiles[0], nil
}

func (h *HoeInfo) Print() {
	// fmt.Printf("=========== Hoe %s ===========\n", hoe.Profiles[0])
	// fmt.Printf("Url: %s\n", hoe.Url)

	// // Print all fields in Main info
	// fmt.Printf("Name: %s\n", hoe.Name)
	// fmt.Printf("Image url: %s\n", hoe.ImageUrl)
	// fmt.Printf("Price: %s\n", hoe.Price)
	// fmt.Printf("Phone: %s\n", hoe.Phone)
	// fmt.Printf("Address: %s\n", hoe.Address)
	// fmt.Printf("Provider: %s\n", hoe.Provider)
	// fmt.Printf("Status: %s\n", hoe.Status)
	// fmt.Printf("Birth year: %s\n", hoe.BirthYear)
	// fmt.Printf("Height: %s\n", hoe.Height)
	// fmt.Printf("Weight: %s\n", hoe.Weight)
	// fmt.Printf("From: %s\n", hoe.Country)
	// fmt.Printf("Service: %s\n", hoe.Service)
	// fmt.Printf("Work Time: %s\n", hoe.WorkTime)
	// fmt.Printf("Duration: %s\n", hoe.Duration)
	// fmt.Printf("Report count: %d\n", len(hoe.Reports))

	// fmt.Println("==============================")
	fmt.Print("\n\n")
}

================
File: internal/models/reporter.go
================
package models

type Reporter struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	Url  string `json:"url"`
}

================
File: internal/models/site.go
================
package models

import "time"

type Site struct {
	ID        uint      `gorm:"primaryKey"`
	Name      string    `gorm:"column:name"`
	BaseURL   string    `gorm:"column:base_url"`
	IsExpired bool      `gorm:"column:is_expired"`
	CreatedAt time.Time `gorm:"column:created_at;autoCreateTime"`
	UpdatedAt time.Time `gorm:"column:updated_at;autoUpdateTime"`
}

func (Site) TableName() string {
	return "sites"
}

================
File: internal/models/street.go
================
package models

type Street struct {
	ID         uint   `gorm:"primaryKey"`
	Name       string `gorm:"column:name"`
	Code       string `gorm:"column:code"`
	DistrictID uint   `gorm:"column:district_id;index"`
}

func (Street) TableName() string {
	return "street"
}

================
File: internal/models/working_history.go
================
package models

import "time"

type WorkingHistory struct {
	ID         uint       `gorm:"primaryKey"`
	HoeID      uint       `gorm:"column:hoe_id;index"`
	StartDate  time.Time  `gorm:"column:start_date"`
	EndDate    *time.Time `gorm:"column:end_date"`
	CityID     uint       `gorm:"column:city_id;index"`
	DistrictID uint       `gorm:"column:district_id;index"`
	CreatedAt  time.Time  `gorm:"column:created_at"`
	UpdatedAt  time.Time  `gorm:"column:updated_at"`

	Hoe      HoeInfo  `gorm:"foreignKey:HoeID;"`
	City     City     `gorm:"foreignKey:CityID;references:ID;constraint:OnDelete:CASCADE"`
	District District `gorm:"foreignKey:DistrictID;references:ID;constraint:OnDelete:CASCADE"`
}

func (WorkingHistory) TableName() string {
	return "working_histories"
}

================
File: internal/repository/hoe.go
================
package repository

import (
	"errors"
	"fmt"
	"time"

	"github.com/haovoanh28/gai-webscraper/internal/models"
	"github.com/haovoanh28/gai-webscraper/internal/utils/logutil"
	"gorm.io/gorm"
)

type HoeRepository interface {
	Save(hoe *models.HoeInfo) error
	GetHoeByPhone(phone string) (*models.HoeInfo, error)
}

type hoeRepo struct {
	db     *gorm.DB
	logger *logutil.Logger
}

func NewHoeRepository(db *gorm.DB, logger *logutil.Logger) HoeRepository {
	return &hoeRepo{db: db, logger: logger}
}

func (r *hoeRepo) Save(hoe *models.HoeInfo) error {
	tx := r.db.Begin()

	// Try to find existing hoe by phone
	var existingHoe models.HoeInfo
	err := tx.Where("phone = ?", hoe.Phone).First(&existingHoe).Error

	if errors.Is(err, gorm.ErrRecordNotFound) {
		// First time this hoe is scraped
		if err := tx.Create(hoe).Error; err != nil {
			tx.Rollback()
			return fmt.Errorf("failed to create new hoe: %v", err)
		}

		r.logger.Info(fmt.Sprintf("Created new hoe: %s with profile from %s",
			hoe.Name, hoe.Profiles[0].Site.Name))

	} else if err != nil {
		tx.Rollback()
		return fmt.Errorf("database error: %v", err)

	} else {
		// Hoe exists, handle profile update
		if err := r.updateExistingHoe(tx, &existingHoe, hoe); err != nil {
			tx.Rollback()
			return err
		}

		r.logger.Info(fmt.Sprintf("Updated existing hoe: %s with profile from %s",
			hoe.Name, hoe.Profiles[0].Site.Name))
	}

	return tx.Commit().Error
}

func (r *hoeRepo) updateExistingHoe(tx *gorm.DB, existing *models.HoeInfo, new *models.HoeInfo) error {
	// Update common info
	if err := tx.Model(existing).Updates(models.HoeInfo{
		Name:          new.Name,
		BirthYear:     new.BirthYear,
		Height:        new.Height,
		Weight:        new.Weight,
		Country:       new.Country,
		LastScrapedAt: time.Now(), // Always non-zero since it's current time
	}).Error; err != nil {
		return fmt.Errorf("failed to update hoe info: %v", err)
	}

	// Handle profile update
	newProfile := new.Profiles[0]
	var existingProfile models.HoeProfile

	err := tx.Where("hoe_id = ? AND site_id = ?",
		existing.ID, newProfile.SiteID).First(&existingProfile).Error

	if errors.Is(err, gorm.ErrRecordNotFound) {
		// First profile from this site
		newProfile.HoeID = existing.ID
		if err := tx.Create(&newProfile).Error; err != nil {
			return fmt.Errorf("failed to create new profile: %v", err)
		}
	} else if err != nil {
		return fmt.Errorf("database error: %v", err)
	} else {
		// Update existing profile
		if err := tx.Model(&existingProfile).Updates(models.HoeProfile{
			OriginID: newProfile.OriginID,
			Url:      newProfile.Url,
			ImageUrl: newProfile.ImageUrl,
			Price:    newProfile.Price,
			Provider: newProfile.Provider,
			Area:     newProfile.Area,
			Status:   newProfile.Status,
			Service:  newProfile.Service,
			Duration: newProfile.Duration,
			WorkTime: newProfile.WorkTime,
		}).Error; err != nil {
			return fmt.Errorf("failed to update profile: %v", err)
		}
	}

	return nil
}

func (r *hoeRepo) GetHoeByPhone(phone string) (*models.HoeInfo, error) {
	var hoe models.HoeInfo
	if err := r.db.Where("phone = ?", phone).First(&hoe).Error; err != nil {
		return nil, err
	}
	return &hoe, nil
}

================
File: internal/repository/location.go
================
package repository

import (
	"github.com/haovoanh28/gai-webscraper/internal/models"
	"gorm.io/gorm"
)

type LocationRepository interface {
	CheckValidLocation(district string) error
}

type locationRepo struct {
	db *gorm.DB
}

func NewLocationRepository(db *gorm.DB) LocationRepository {
	return &locationRepo{db: db}
}

func (r *locationRepo) CheckValidLocation(district string) error {
	if err := r.db.Where("name = ? ", district).Or("short_name = ?").Or("code = ? ").First(&models.District{}).Error; err != nil {
		return err
	}

	return nil
}

================
File: internal/repository/site.go
================
package repository

import (
	"github.com/haovoanh28/gai-webscraper/internal/models"
	"gorm.io/gorm"
)

type SiteRepository interface {
	GetSiteByName(name string) (*models.Site, error)
}

type siteRepo struct {
	db *gorm.DB
}

func NewSiteRepository(db *gorm.DB) SiteRepository {
	return &siteRepo{db: db}
}

func (r *siteRepo) GetSiteByName(name string) (*models.Site, error) {
	var site models.Site
	if err := r.db.Model(&models.Site{}).Where("name = ?", name).First(&site).Error; err != nil {
		return nil, err
	}

	return &site, nil
}

================
File: internal/repository/working_history.go
================
package repository

import (
	"github.com/haovoanh28/gai-webscraper/internal/utils/logutil"
	"gorm.io/gorm"
)

type WorkingHistoryRepository interface {
}

type workingHistory struct {
	db     *gorm.DB
	logger *logutil.Logger
}

func NewWorkingHistoryRepository(db *gorm.DB, logger *logutil.Logger) WorkingHistoryRepository {
	return &workingHistory{db: db, logger: logger}
}

================
File: internal/scrapers/gaito/detail.go
================
package gaito

import (
	"time"

	"github.com/haovoanh28/gai-webscraper/internal/dto"

	"github.com/haovoanh28/gai-webscraper/internal/infrastructure/browser"
	"github.com/haovoanh28/gai-webscraper/internal/models"
	"github.com/haovoanh28/gai-webscraper/internal/utils"
	"github.com/haovoanh28/gai-webscraper/internal/utils/errutil"
)

type detailPageScraper struct {
	conn *browser.Connection
	url  string
}

func newDetailPageScraper(conn *browser.Connection, url string) *detailPageScraper {
	return &detailPageScraper{conn: conn, url: url}
}

func (s *detailPageScraper) getBasicInfo() (*dto.RawHoeData, error) {
	id := utils.GetIDFromUrl(s.url)

	containerEle, err := s.conn.Root.Find(detailPageSelectors.PageContainer)
	if err != nil {
		return nil, errutil.WrapError("get container element", err, s.url)
	}

	detailInfoTabEle, err := containerEle.Find(detailPageSelectors.DetailInfoTab)
	if err != nil {
		return nil, errutil.WrapError("get detail info tab element", err, s.url)
	}

	rawInfo := &dto.RawHoeData{
		OriginID: id,
		Url:      s.url,
	}

	rawInfo.Name = containerEle.MustFind(detailPageSelectors.Name).MustGetText()
	rawInfo.ImageUrl = containerEle.MustFind(detailPageSelectors.ImageUrl).MustGetAttribute("src")
	rawInfo.Price = detailInfoTabEle.MustFind(detailPageSelectors.Price).MustGetText()
	rawInfo.Phone = detailInfoTabEle.MustFind(detailPageSelectors.Phone).MustGetText()
	rawInfo.Address = detailInfoTabEle.MustFind(detailPageSelectors.Address).MustGetText()
	rawInfo.Provider = detailInfoTabEle.MustFind(detailPageSelectors.Author).MustGetText()
	rawInfo.Status = detailInfoTabEle.MustFind(detailPageSelectors.Status).MustGetText()
	rawInfo.BirthYear = detailInfoTabEle.MustFind(detailPageSelectors.BirthYear).MustGetText()
	rawInfo.Height = detailInfoTabEle.MustFind(detailPageSelectors.Height).MustGetText()
	rawInfo.Weight = detailInfoTabEle.MustFind(detailPageSelectors.Weight).MustGetText()
	rawInfo.Country = detailInfoTabEle.MustFind(detailPageSelectors.Country).MustGetText()
	rawInfo.Service = detailInfoTabEle.MustFind(detailPageSelectors.Service).MustGetText()
	rawInfo.Duration = detailInfoTabEle.MustFind(detailPageSelectors.Duration).MustGetText()
	rawInfo.WorkTime = detailInfoTabEle.MustFind(detailPageSelectors.WorkTime).MustGetText()

	return rawInfo, nil
}

func (s *detailPageScraper) getReportURLs() ([]*models.HoeReport, error) {
	var reports []*models.HoeReport
	reportTabEle, err := s.conn.Root.Find(detailPageSelectors.ReportTab)
	if err != nil {
		return nil, errutil.WrapError("get report tab element", err, s.url)
	}

	if err := reportTabEle.Click(); err != nil {
		return nil, errutil.WrapError("click report tab element", err, s.url)
	}

	if err := reportTabEle.WaitVisible(); err != nil {
		return nil, errutil.WrapError("wait report tab element visible", err, s.url)
	}

	reportTabContentEle, err := s.conn.Root.Find(detailPageSelectors.ReportTabContent)
	if err != nil {
		return nil, errutil.WrapError("get report tab content element", err, s.url)
	}

	for {
		// reportsEle, err := browser.GetMultipleElementsWithRetry(reportTabContentEle, detailPageSelectors.ReportList)
		reportsEle, err := reportTabContentEle.FindAll(detailPageSelectors.ReportList)
		if err != nil {
			return nil, errutil.WrapError("get report elements", err, s.url)
		}

		for _, reportEle := range reportsEle {
			// reportUrl, err := browser.GetElementAttribute(reportEle, detailPageSelectors.ReportViewMoreBtn, "href")
			reportUrl, err := reportEle.MustFind(detailPageSelectors.ReportViewMoreBtn).GetAttribute("href")
			if err != nil {
				return nil, errutil.WrapError("get report url", err, s.url)
			}
			reports = append(reports, &models.HoeReport{
				ReportURL: reportUrl,
			})
		}

		goNextPageBtn, err := s.conn.Root.Find(detailPageSelectors.ReportGoNextPageBtn)
		if err != nil {
			break
		} else {
			// Click go next page button
			if err := goNextPageBtn.Click(); err != nil {
				return nil, errutil.WrapError("click go next page button", err, s.url)
			}

			time.Sleep(1 * time.Second)
		}
	}

	return reports, nil
}

================
File: internal/scrapers/gaito/list.go
================
package gaito

import (
	"github.com/haovoanh28/gai-webscraper/internal/infrastructure/browser"
	"github.com/haovoanh28/gai-webscraper/internal/utils/errutil"
)

type listPageScraper struct {
	conn *browser.Connection
	url  string
}

func newListPageScraper(conn *browser.Connection, url string) *listPageScraper {
	return &listPageScraper{conn: conn, url: url}
}

func (s *listPageScraper) getHoeURLs() ([]string, error) {
	const (
		itemThreshold = 30
	)
	var urlList []string
	for {
		items, err := s.conn.Root.FindAll(listPageSelectors.Items)
		if err != nil {
			return nil, errutil.WrapError("get list items", err, s.url)
		}

		// currentLength >= itemThreshold: enough items
		// currentLength == 0: for some reason, the query doesn't return any items (Ex: Cloudflare, ...)
		currentLength := len(items)
		if currentLength >= itemThreshold || currentLength == 0 {
			break
		}

		loadMoreBtn, err := s.conn.Root.Find(listPageSelectors.LoadMoreBtn)
		if err != nil {
			break
		}

		if err := loadMoreBtn.Click(); err != nil {
			return nil, errutil.WrapError("click load more button", err, s.url)
		}

		if err := s.conn.Page.WaitElementsMoreThan(listPageSelectors.Items, currentLength); err != nil {
			return nil, errutil.WrapError("wait more items", err, s.url)
		}
	}

	elements, err := s.conn.Root.FindAll(listPageSelectors.Items)
	if err != nil {
		return nil, errutil.WrapError("get final list items", err, s.url)
	}

	for _, elem := range elements {
		urlList = append(urlList, elem.MustFind(listPageSelectors.ThumbnailUrl).MustGetAttribute("href"))
	}

	return urlList, nil
}

================
File: internal/scrapers/gaito/report.go
================
package gaito

// import (
// 	"fmt"
// 	"strconv"

// 	"github.com/go-rod/rod"
// 	"github.com/haovoanh28/gai-webscraper/internal/models"
// 	"github.com/haovoanh28/gai-webscraper/internal/utils"
// 	"github.com/haovoanh28/gai-webscraper/internal/utils/browser"
// )

// func ProcessReportPage(reportUrl string) models.HoeReportInfo {
// 	url := BaseUrl + reportUrl
// 	id := utils.GetIDFromUrl(reportUrl)

// 	reportInfo := models.HoeReportInfo{
// 		ID:        id,
// 		DetailUrl: reportUrl,
// 	}

// 	page := rod.New().MustConnect().MustPage(url).MustWaitStable()
// 	element := page.MustElement(`review-detail-cmp`).MustWaitVisible()
// 	defer page.Close()

// 	stars, err := page.Elements(`span[ng-model="data.review.score"] i.fa-heart[ng-repeat="r in range track by $index"]`)
// 	if err != nil {
// 		panic(fmt.Errorf(`failed to get stars: %v`, err))
// 	}
// 	reportInfo.Rating = strconv.Itoa(len(stars))

// 	reportInfo.Description = browser.GetElementText(element, `div[ng-switch-when="textarea"] span[ng-bind="elem.question.response"]`, id+"_report_description")

// 	// Process author
// 	authorSectionElement, err := page.Element(`div.ow_page_padding > div > div > div > div > div > div:nth-child(3) > div > div.col-md-4 > div:nth-child(2) > div > div.ow_user_list_data`)
// 	if err != nil {
// 		panic(fmt.Errorf(`failed to get author section: %v`, err))
// 	}
// 	authorUrlElement := authorSectionElement.MustElement(`a.ng-binding`)
// 	authorUrl := authorUrlElement.MustAttribute(`href`)
// 	reportInfo.Author = &models.Reporter{
// 		ID:   utils.GetIDFromUrl(*authorUrl),
// 		Name: authorUrlElement.MustText(),
// 		Url:  *authorUrl,
// 	}
// 	reportInfo.Time = browser.GetElementText(element, `div.ow_page_padding > div > div > div > div > div > div:nth-child(3) > div > div.col-md-8 > review-detail-cmp > div:nth-child(1) > em > small`, id+"_report_time")

// 	return reportInfo
// }

================
File: internal/scrapers/gaito/scraper.go
================
package gaito

import (
	"fmt"
	"time"

	"github.com/haovoanh28/gai-webscraper/internal/definitions"
	"github.com/haovoanh28/gai-webscraper/internal/dto"
	"github.com/haovoanh28/gai-webscraper/internal/infrastructure/browser"
)

type scraper struct {
	definitions.ScraperConfig
}

func NewScraper(config definitions.ScraperConfig) *scraper {
	return &scraper{
		config,
	}
}

func (s *scraper) GetDetailURLs() ([]string, error) {
	url := s.BaseURL + "/gai-goi/khu-vuc/Hồ%20Chí%20Minh/Quận%207"

	s.Logger.Info(fmt.Sprintf("Processing %s", url))

	conn, err := browser.ConnectToPage(url, 30*time.Second)
	if err != nil {
		return nil, fmt.Errorf("connect to page %s: %w", url, err)
	}
	defer conn.Close()

	listScraper := newListPageScraper(conn, url)
	return listScraper.getHoeURLs()
}

func (s *scraper) GetRawHoeData(detailUrl string) (*dto.RawHoeData, error) {
	url := s.BaseURL + detailUrl

	// Wait until content element is visible
	conn, err := browser.ConnectToPage(url, 2*time.Minute)
	if err != nil {
		return nil, fmt.Errorf("connect to detail page %s: %w", url, err)
	}
	defer conn.Close()

	detailScraper := newDetailPageScraper(conn, url)
	hoeInfo, err := detailScraper.getBasicInfo()
	if err != nil {
		return nil, fmt.Errorf("get basic info %s: %w", url, err)
	}

	// Get report urls
	// reports, err := detailScraper.getReportURLs()
	// if err != nil {
	// 	return nil, errutil.WrapError("get report urls", err, url)
	// }

	// hoeInfo.Reports = reports
	return hoeInfo, nil
}

================
File: internal/scrapers/gaito/selectors.go
================
package gaito

// ListPageSelectors contains all selectors used in list page scraping
type ListPageSelectors struct {
	Items        string
	LoadMoreBtn  string
	ThumbnailUrl string
}

type DetailPageSelectors struct {
	PageContainer  string
	DetailInfoTab  string
	DetailInfoCard string

	ReportTab           string
	ReportTabContent    string
	ReportList          string
	ReportViewMoreBtn   string
	ReportGoNextPageBtn string

	Name      string
	ImageUrl  string
	Price     string
	Phone     string
	Address   string
	Author    string
	Status    string
	BirthYear string
	Height    string
	Weight    string
	Country   string
	Service   string
	Duration  string
	WorkTime  string
}

var (
	listPageSelectors = ListPageSelectors{
		Items:        `div[ng-repeat="item in products"]`,
		LoadMoreBtn:  `body > div.container.seduction-container > div.knn_page_wrap > div.ow_page_padding > div > div > div > div > div > div:nth-child(3) > div:nth-child(4) > div > button`,
		ThumbnailUrl: `.thumbnail a`,
	}

	detailPageSelectors = DetailPageSelectors{
		PageContainer:  `.container.seduction-container .ow_page_container`,
		DetailInfoTab:  `.tab-content`,
		DetailInfoCard: `.jumbotron.ng-scope`,

		ReportTab:           `li[index="2"] a.nav-link`,
		ReportTabContent:    `product-review[ng-if="reviewTabLoaded"] div.panel-body`,
		ReportList:          `div[ng-repeat="review in reviews"]`,
		ReportViewMoreBtn:   `a.view_more_report`,
		ReportGoNextPageBtn: `product-review li.pagination-next:not(.disabled) a[ng-click]`,

		Name:      `div:nth-child(3) > div > h1`,
		ImageUrl:  `div:nth-child(3) > div > div:nth-child(3) > div > div > div > div.tab-pane.ng-scope.active > div.jumbotron.ng-scope > div > div.col-md-3.col-sm-4.media.escort_item_wrap > div > image-placeholder > img`,
		Price:     `.jumbotron .fa.fa-money + span`,
		Phone:     `.jumbotron .fa.fa-phone + a`,
		Address:   `.jumbotron .fa.fa-map-marker + a`,
		Author:    `.jumbotron .fa.fa-user + a`,
		Status:    `.jumbotron .fa.fa-file-o + span`,
		BirthYear: `product-attribute table > tbody > tr:nth-child(3) > td:nth-child(2) > attribute-dob-box > div > div`,
		Height:    `product-attribute table > tbody > tr:nth-child(4) > td:nth-child(2) > attribute-number-box .ng-scope`,
		Weight:    `product-attribute table > tbody > tr:nth-child(5) > td:nth-child(2) > attribute-number-box .ng-scope`,
		Country:   `product-attribute table > tbody > tr:nth-child(9) > td:nth-child(2) > attribute-radio-box span span[ng-repeat="item in attributeDto.settings.values"]`,
		Service:   `product-attribute table > tbody > tr:nth-child(12) > td:nth-child(2) > attribute-choices-box span span[ng-repeat="item in attributeDto.settings.values"]`,
		Duration:  `product-attribute table > tbody > tr:nth-child(15) > td:nth-child(2) > attribute-text-box span`,
		WorkTime:  `product-attribute table > tbody > tr:nth-child(16) > td:nth-child(2) > attribute-text-box span`,
	}
)

================
File: internal/scrapers/factory.go
================
package scrapers

import (
	"github.com/haovoanh28/gai-webscraper/internal/definitions"
	"github.com/haovoanh28/gai-webscraper/internal/interfaces"
	"github.com/haovoanh28/gai-webscraper/internal/scrapers/gaito"
)

func CreateScraper(baseConfig definitions.ScraperConfig) interfaces.Scraper {
	switch baseConfig.SiteName {
	case "gaito":
		return gaito.NewScraper(baseConfig)
	case "gaigu":
		return gaito.NewScraper(baseConfig)
	default:
		return nil
	}
}

================
File: internal/service/hoe.go
================
package service

import (
	"fmt"

	"github.com/haovoanh28/gai-webscraper/internal/interfaces"
	"github.com/haovoanh28/gai-webscraper/internal/repository"
	"github.com/haovoanh28/gai-webscraper/internal/utils/errutil"
	"github.com/haovoanh28/gai-webscraper/internal/utils/logutil"
)

type HoeService interface {
	ProcessListPage() error
	ProcessDetailPage(url string) error
}

type HoeServiceConfig struct {
	HoeRepo            repository.HoeRepository
	WorkingHistoryRepo repository.WorkingHistoryRepository
	Logger             *logutil.Logger
	Scraper            interfaces.Scraper
	Mapper             MapperService
	ValidateService    ValidateService
}

type hoeService struct {
	hoeRepo            repository.HoeRepository
	workingHistoryRepo repository.WorkingHistoryRepository
	logger             *logutil.Logger
	scraper            interfaces.Scraper
	mapper             MapperService
	validateService    ValidateService
}

func NewHoeService(config HoeServiceConfig) HoeService {
	return &hoeService{
		hoeRepo:            config.HoeRepo,
		workingHistoryRepo: config.WorkingHistoryRepo,
		logger:             config.Logger,
		scraper:            config.Scraper,
		mapper:             config.Mapper,
		validateService:    config.ValidateService,
	}
}

func (hs *hoeService) ProcessListPage() error {
	detailURLs, err := hs.scraper.GetDetailURLs()
	if err != nil {
		return errutil.WrapError("get detail urls", err, "no target")
	}

	if len(detailURLs) == 0 {
		hs.logger.Warn("No items found (Maybe Cloudflare block ?)")
	} else {
		hs.logger.Info(fmt.Sprintf("Found %d items\n", len(detailURLs)))

		for _, url := range detailURLs {
			hs.logger.Info(url)
		}
	}

	return nil
}

func (hs *hoeService) ProcessDetailPage(url string) error {
	url2 := "/gai-goi/chi-tiet/56042/hot-girl-diep-anhmat-xinh-nguc-dep-bu-cu-dieu-luyen"

	rawHoe, err := hs.scraper.GetRawHoeData(url2)
	if err != nil {
		return errutil.WrapError("get raw hoe data", err, url)
	}

	hoeInfo := hs.mapper.TransformHoe(rawHoe)
	hoeInfo.Print()

	if err := hs.validateService.ValidateHoe(hoeInfo); err != nil {
		return err
	}

	return nil
}

================
File: internal/service/mapper.go
================
package service

import (
	"strings"

	"github.com/haovoanh28/gai-webscraper/internal/definitions"
	"github.com/haovoanh28/gai-webscraper/internal/dto"
	"github.com/haovoanh28/gai-webscraper/internal/models"
)

type MapperService interface {
	TransformHoe(rawInfo *dto.RawHoeData) *models.HoeInfo
}

type mapperService struct{}

func NewMapperService() MapperService {
	return &mapperService{}
}

func (s *mapperService) TransformHoe(rawInfo *dto.RawHoeData) *models.HoeInfo {
	rawInfo.Price = s.normalizePrice(rawInfo.Price)
	rawInfo.Phone = s.normalizePhone(rawInfo.Phone)

	return &models.HoeInfo{
		Name:      strings.TrimSpace(rawInfo.Name),
		Phone:     rawInfo.Phone,
		BirthYear: rawInfo.BirthYear,
		Height:    rawInfo.Height,
		Weight:    rawInfo.Weight,
		Country:   rawInfo.Country,

		Profiles: []models.HoeProfile{
			{
				SiteID:   rawInfo.SiteID,
				OriginID: rawInfo.OriginID,
				Url:      rawInfo.Url,
				ImageUrl: rawInfo.ImageUrl,
				Price:    rawInfo.Price,
				Provider: rawInfo.Provider,
				Status:   s.mapStatus(rawInfo.Status),
				Service:  rawInfo.Service,
				Duration: rawInfo.Duration,
				WorkTime: rawInfo.WorkTime,
			},
		},
	}
}

func (s *mapperService) normalizePrice(price string) string {
	// First clean up any special characters and spaces
	price = strings.ReplaceAll(price, "\u00A0", "")
	price = strings.ReplaceAll(price, ",", "")
	price = strings.ToLower(price)

	// Remove any spaces
	price = strings.ReplaceAll(price, " ", "")

	// Remove 'k' and 'vnd'
	price = strings.ReplaceAll(price, "k", "")
	price = strings.ReplaceAll(price, "vnd", "")

	return price
}

func (s *mapperService) normalizePhone(phone string) string {
	phone = strings.ReplaceAll(phone, ".", "")
	phone = strings.ReplaceAll(phone, "-", "")
	phone = strings.ReplaceAll(phone, " ", "")

	return phone
}

func (s *mapperService) mapStatus(status string) definitions.HoeStatus {
	status = strings.ToLower(strings.TrimSpace(status))
	switch status {
	case "đang rảnh", "online", "hoạt động":
		return definitions.HoeStatusActive
	case "bận", "offline":
		return definitions.HoeStatusInactive
	default:
		return definitions.HoeStatusUnknown
	}
}

================
File: internal/service/validate.go
================
package service

import (
	"errors"
	"github.com/haovoanh28/gai-webscraper/internal/definitions"
	"github.com/haovoanh28/gai-webscraper/internal/models"
	"github.com/haovoanh28/gai-webscraper/internal/repository"
	"strings"
)

type ValidateService interface {
	ValidateHoe(hoe *models.HoeInfo) error
}

type validateService struct {
	locationRepo repository.LocationRepository
}

func NewValidateService(locationRepo repository.LocationRepository) ValidateService {
	return &validateService{locationRepo: locationRepo}
}

func (s *validateService) ValidateHoe(hoe *models.HoeInfo) error {
	scrapingProfile, err := hoe.GetCurrentScrapingProfile()
	if err != nil {
		return err
	}

	if err := validateLocation(scrapingProfile.Area); err != nil {
		return err
	}

	return nil
}

func validateLocation(location string) error {
	if location == "" {
		return errors.New("location cannot be empty")
	}

	parsedLocation := parseLocation(location)
	
	return nil
}

func parseLocation(location string) definitions.ParsedAddress {
	// Trim any leading/trailing whitespace
	address = strings.TrimSpace(address)

	// Split the address into parts
	parts := strings.Split(address, ",")

	parsed := definitions.ParsedAddress{
		Street:   "",
		District: "",
	}

	if len(parts) >= 1 {
		parsed.Street = strings.TrimSpace(parts[0])
	}

	if len(parts) >= 2 {
		// Handle potential district abbreviations
		district := strings.TrimSpace(parts[1])
		district = strings.ReplaceAll(district, "Q.", "Quận ")
		district = strings.ReplaceAll(district, "Quan ", "Quận ")
		parsed.District = district
	}

	return parsed
}

================
File: internal/utils/errutil/handler.go
================
package errutil

import (
	"runtime"
	"strings"
)

type ScrapeError struct {
	Op     string // Operation being performed
	Target string // Target being scraped (URL, selector, etc)
	Err    error  // Original error
	File   string // Source file where error occurred
	Line   int    // Line number where error occurred
}

func (se *ScrapeError) Error() string {
	parts := []string{se.Op}

	if se.Target != "" {
		parts = append(parts, "target: "+se.Target)
	}
	if se.Err != nil {
		parts = append(parts, "error: "+se.Err.Error())
	}

	return strings.Join(parts, " - ")
}

func WrapError(op string, err error, target string) error {
	if err == nil {
		return nil
	}

	_, file, line, _ := runtime.Caller(1)

	serr := &ScrapeError{
		Op:     op,
		Target: target,
		Err:    err,
		File:   file,
		Line:   line,
	}

	return serr
}

================
File: internal/utils/logutil/handler.go
================
package logutil

import (
	"log"
	"os"
)

type Logger struct {
	logger   *log.Logger
	minLevel LogLevel
}

func NewLogger(minLevel LogLevel) *Logger {
	return &Logger{
		logger:   log.Default(),
		minLevel: minLevel,
	}
}

func (l *Logger) Log(level LogLevel, msg string, args ...interface{}) {
	if level >= l.minLevel {
		l.logger.Printf("["+level.String()+"] "+msg, args...)
	}
}

func (l *Logger) Debug(msg string, args ...interface{}) {
	l.Log(DEBUG, msg, args...)
}

func (l *Logger) Info(msg string, args ...interface{}) {
	l.Log(INFO, msg, args...)
}

func (l *Logger) Warn(msg string, args ...interface{}) {
	l.Log(WARN, msg, args...)
}

func (l *Logger) Error(msg string, args ...interface{}) {
	l.Log(ERROR, msg, args...)
}

func (l *Logger) Fatal(msg string, args ...interface{}) {
	l.Log(FATAL, msg, args...)
	// panic(msg) // or os.Exit(1) depending on your needs
	os.Exit(1)
}

================
File: internal/utils/logutil/level.go
================
package logutil

import (
	"fmt"
	"strings"
)

type LogLevel int

const (
	DEBUG LogLevel = iota
	INFO
	WARN
	ERROR
	FATAL
)

func (l LogLevel) String() string {
	switch l {
	case DEBUG:
		return "DEBUG"
	case INFO:
		return "INFO"
	case WARN:
		return "WARN"
	case ERROR:
		return "ERROR"
	case FATAL:
		return "FATAL"
	default:
		return "UNKNOWN"
	}
}

func ParseLogLevel(level string) (LogLevel, error) {
	switch strings.ToUpper(level) {
	case "DEBUG":
		return DEBUG, nil
	case "INFO":
		return INFO, nil
	case "WARN":
		return WARN, nil
	case "ERROR":
		return ERROR, nil
	case "FATAL":
		return FATAL, nil
	default:
		return INFO, fmt.Errorf("unknown log level: %s", level)
	}
}

================
File: internal/utils/setuputil/setup.go
================
package setuputil

import (
	"flag"
	"fmt"
	"log"
	"os"

	"github.com/haovoanh28/gai-webscraper/internal/definitions"
	"github.com/haovoanh28/gai-webscraper/internal/infrastructure/database"
	"github.com/haovoanh28/gai-webscraper/internal/interfaces"
	"github.com/haovoanh28/gai-webscraper/internal/repository"
	"github.com/haovoanh28/gai-webscraper/internal/scrapers"
	"github.com/haovoanh28/gai-webscraper/internal/service"
	"github.com/haovoanh28/gai-webscraper/internal/utils/logutil"
)

type AppContext struct {
	Scraper    interfaces.Scraper
	HoeService service.HoeService
	Logger     *logutil.Logger
}

func InitLogger() *logutil.Logger {
	log.SetFlags(log.LstdFlags)

	logLevelStr := os.Getenv("LOG_LEVEL")
	logLevel, err := logutil.ParseLogLevel(logLevelStr)
	if err != nil {
		log.Printf("Invalid log level '%s', defaulting to INFO", logLevelStr)
		logLevel = logutil.INFO
	}

	return logutil.NewLogger(logLevel)
}

func CreateAppContext() (*AppContext, error) {
	// Get site from cmd options
	site := flag.String("site", "", "The site to scrape")
	flag.Parse()

	logger := InitLogger()

	db, err := database.InitDB()
	if err != nil {
		return nil, fmt.Errorf("failed to initialize database: %v", err)
	}

	siteRepo := repository.NewSiteRepository(db)
	siteInfo, err := siteRepo.GetSiteByName(*site)
	if err != nil {
		return nil, fmt.Errorf("failed to get site by name: %v", err)
	}

	baseConfig := definitions.ScraperConfig{
		SiteID:            siteInfo.ID,
		SiteName:          siteInfo.Name,
		BaseURL:           siteInfo.BaseURL,
		RequestsPerSecond: 1.0,
		Logger:            logger,
	}

	scraper := scrapers.CreateScraper(baseConfig)

	hoeRepo := repository.NewHoeRepository(db, logger)
	locationRepo := repository.NewLocationRepository(db)
	workingHistoryRepo := repository.NewWorkingHistoryRepository(db, logger)

	hoeServiceConfig := service.HoeServiceConfig{
		HoeRepo:            hoeRepo,
		WorkingHistoryRepo: workingHistoryRepo,
		Logger:             logger,
		Scraper:            scraper,
		Mapper:             service.NewMapperService(),
		ValidateService:    service.NewValidateService(locationRepo),
	}
	hoeService := service.NewHoeService(hoeServiceConfig)

	return &AppContext{
		Scraper:    scraper,
		Logger:     logger,
		HoeService: hoeService,
	}, nil
}

================
File: internal/utils/common.go
================
package utils

import (
	"fmt"
	"regexp"
	"strings"
)

func GetIDFromUrl(url string) string {
	url = strings.TrimSuffix(url, "/")

	// Pattern 1: "/x/y/id/z" - extract ID between segments
	re1 := regexp.MustCompile(`/([^/]+)/[^/]+$`)
	if match := re1.FindStringSubmatch(url); len(match) >= 2 {
		return match[1]
	}

	// Pattern 2: "/a/id" - extract ID at the end
	re2 := regexp.MustCompile(`/([^/]+)$`)
	if match := re2.FindStringSubmatch(url); len(match) >= 2 {
		return match[1]
	}

	return ""
}

func HandleError(err error, operation string, fieldName string) {
	if err != nil {
		panic(fmt.Errorf(`failed to %s "%s": %v`, operation, fieldName, err))
	}
}

================
File: .gitignore
================
# Binary files
*.exe
*.exe~
*.dll
*.so
*.dylib

# Binary folder (common Go build output)
/bin/

# Go specific
*.test
*.out

# IDE stuff
.idea/
.vscode/
*.swp
*.swo

# OS generated files
.DS_Store
.DS_Store?
._*

# Environment files
.env
.env.local
.env.development
.env.production

================
File: docker-compose.yml
================
services:
  mariadb:
    image: mariadb:11.6-ubi
    container_name: gai-scraper-db
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root123
      MYSQL_DATABASE: gai-scraper
      MYSQL_USER: hao
      MYSQL_PASSWORD: password123
    ports:
      - "3306:3306"
    volumes:
      - gai_scraper_mariadb_data:/var/lib/mysql

volumes:
  gai_scraper_mariadb_data:

================
File: go.mod
================
module github.com/haovoanh28/gai-webscraper

go 1.23

toolchain go1.23.2

require (
	github.com/chromedp/cdproto v0.0.0-20241014181340-cb3a7a1d51d7
	github.com/chromedp/chromedp v0.11.0
)

require (
	filippo.io/edwards25519 v1.1.0 // indirect
	github.com/chromedp/sysutil v1.1.0 // indirect
	github.com/go-rod/rod v0.116.2 // indirect
	github.com/go-rod/stealth v0.4.9 // indirect
	github.com/go-sql-driver/mysql v1.8.1 // indirect
	github.com/gobwas/httphead v0.1.0 // indirect
	github.com/gobwas/pool v0.2.1 // indirect
	github.com/gobwas/ws v1.4.0 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/joho/godotenv v1.5.1 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/ysmood/fetchup v0.2.4 // indirect
	github.com/ysmood/goob v0.4.0 // indirect
	github.com/ysmood/got v0.40.0 // indirect
	github.com/ysmood/gson v0.7.3 // indirect
	github.com/ysmood/leakless v0.9.0 // indirect
	golang.org/x/sys v0.26.0 // indirect
	golang.org/x/text v0.20.0 // indirect
	gorm.io/driver/mysql v1.5.7 // indirect
	gorm.io/gorm v1.25.12 // indirect
)

================
File: go.sum
================
filippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=
filippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=
github.com/chromedp/cdproto v0.0.0-20241003230502-a4a8f7c660df/go.mod h1:GKljq0VrfU4D5yc+2qA6OVr8pmO/MBbPEWqWQ/oqGEs=
github.com/chromedp/cdproto v0.0.0-20241014181340-cb3a7a1d51d7 h1:VDBgUGgdCBw9lTKwp0KPExhnqmGfGVJQTER2MehoICk=
github.com/chromedp/cdproto v0.0.0-20241014181340-cb3a7a1d51d7/go.mod h1:GKljq0VrfU4D5yc+2qA6OVr8pmO/MBbPEWqWQ/oqGEs=
github.com/chromedp/chromedp v0.11.0 h1:1PT6O4g39sBAFjlljIHTpxmCSk8meeYL6+R+oXH4bWA=
github.com/chromedp/chromedp v0.11.0/go.mod h1:jsD7OHrX0Qmskqb5Y4fn4jHnqquqW22rkMFgKbECsqg=
github.com/chromedp/sysutil v1.0.0/go.mod h1:kgWmDdq8fTzXYcKIBqIYvRRTnYb9aNS9moAV0xufSww=
github.com/chromedp/sysutil v1.1.0 h1:PUFNv5EcprjqXZD9nJb9b/c9ibAbxiYo4exNWZyipwM=
github.com/chromedp/sysutil v1.1.0/go.mod h1:WiThHUdltqCNKGc4gaU50XgYjwjYIhKWoHGPTUfWTJ8=
github.com/go-rod/rod v0.113.0/go.mod h1:aiedSEFg5DwG/fnNbUOTPMTTWX3MRj6vIs/a684Mthw=
github.com/go-rod/rod v0.116.2 h1:A5t2Ky2A+5eD/ZJQr1EfsQSe5rms5Xof/qj296e+ZqA=
github.com/go-rod/rod v0.116.2/go.mod h1:H+CMO9SCNc2TJ2WfrG+pKhITz57uGNYU43qYHh438Mg=
github.com/go-rod/stealth v0.4.9 h1:X2PmQk4DUF2wzw6GOsWjW/glb8K5ebnftbEvLh7MlZ4=
github.com/go-rod/stealth v0.4.9/go.mod h1:eAzyvw8c0iAd5nJJsSWeh0fQ5z94vCIfdi1hUmYDimc=
github.com/go-sql-driver/mysql v1.7.0/go.mod h1:OXbVy3sEdcQ2Doequ6Z5BW6fXNQTmx+9S1MCJN5yJMI=
github.com/go-sql-driver/mysql v1.8.1 h1:LedoTUt/eveggdHS9qUFC1EFSa8bU2+1pZjSRpvNJ1Y=
github.com/go-sql-driver/mysql v1.8.1/go.mod h1:wEBSXgmK//2ZFJyE+qWnIsVGmvmEKlqwuVSjsCm7DZg=
github.com/gobwas/httphead v0.1.0 h1:exrUm0f4YX0L7EBwZHuCF4GDp8aJfVeBrlLQrs6NqWU=
github.com/gobwas/httphead v0.1.0/go.mod h1:O/RXo79gxV8G+RqlR/otEwx4Q36zl9rqC5u12GKvMCM=
github.com/gobwas/pool v0.2.1 h1:xfeeEhW7pwmX8nuLVlqbzVc7udMDrwetjEv+TZIz1og=
github.com/gobwas/pool v0.2.1/go.mod h1:q8bcK0KcYlCgd9e7WYLm9LpyS+YeLd8JVDW6WezmKEw=
github.com/gobwas/ws v1.4.0 h1:CTaoG1tojrh4ucGPcoJFiAQUAsEWekEWvLy7GsVNqGs=
github.com/gobwas/ws v1.4.0/go.mod h1:G3gNqMNtPppf5XUz7O4shetPpcZ1VJ7zt18dlUeakrc=
github.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=
github.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=
github.com/jinzhu/now v1.1.5 h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=
github.com/jinzhu/now v1.1.5/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
github.com/ledongthuc/pdf v0.0.0-20220302134840-0c2507a12d80 h1:6Yzfa6GP0rIo/kULo2bwGEkFvCePZ3qHDDTC3/J9Swo=
github.com/ledongthuc/pdf v0.0.0-20220302134840-0c2507a12d80/go.mod h1:imJHygn/1yfhB7XSJJKlFZKl/J+dCPAknuiaGOshXAs=
github.com/mailru/easyjson v0.7.7 h1:UGYAvKxe3sBsEDzO8ZeWOSlIQfWFlxbzLZe7hwFURr0=
github.com/mailru/easyjson v0.7.7/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=
github.com/orisano/pixelmatch v0.0.0-20220722002657-fb0b55479cde h1:x0TT0RDC7UhAVbbWWBzr41ElhJx5tXPWkIHA2HWPRuw=
github.com/orisano/pixelmatch v0.0.0-20220722002657-fb0b55479cde/go.mod h1:nZgzbfBr3hhjoZnS66nKrHmduYNpc34ny7RK4z5/HM0=
github.com/ysmood/fetchup v0.2.3 h1:ulX+SonA0Vma5zUFXtv52Kzip/xe7aj4vqT5AJwQ+ZQ=
github.com/ysmood/fetchup v0.2.3/go.mod h1:xhibcRKziSvol0H1/pj33dnKrYyI2ebIvz5cOOkYGns=
github.com/ysmood/fetchup v0.2.4 h1:2kfWr/UrdiHg4KYRrxL2Jcrqx4DZYD+OtWu7WPBZl5o=
github.com/ysmood/fetchup v0.2.4/go.mod h1:hbysoq65PXL0NQeNzUczNYIKpwpkwFL4LXMDEvIQq9A=
github.com/ysmood/goob v0.4.0 h1:HsxXhyLBeGzWXnqVKtmT9qM7EuVs/XOgkX7T6r1o1AQ=
github.com/ysmood/goob v0.4.0/go.mod h1:u6yx7ZhS4Exf2MwciFr6nIM8knHQIE22lFpWHnfql18=
github.com/ysmood/gop v0.0.2/go.mod h1:rr5z2z27oGEbyB787hpEcx4ab8cCiPnKxn0SUHt6xzk=
github.com/ysmood/got v0.34.1/go.mod h1:yddyjq/PmAf08RMLSwDjPyCvHvYed+WjHnQxpH851LM=
github.com/ysmood/got v0.40.0 h1:ZQk1B55zIvS7zflRrkGfPDrPG3d7+JOza1ZkNxcc74Q=
github.com/ysmood/got v0.40.0/go.mod h1:W7DdpuX6skL3NszLmAsC5hT7JAhuLZhByVzHTq874Qg=
github.com/ysmood/gotrace v0.6.0/go.mod h1:TzhIG7nHDry5//eYZDYcTzuJLYQIkykJzCRIo4/dzQM=
github.com/ysmood/gson v0.7.3 h1:QFkWbTH8MxyUTKPkVWAENJhxqdBa4lYTQWqZCiLG6kE=
github.com/ysmood/gson v0.7.3/go.mod h1:3Kzs5zDl21g5F/BlLTNcuAGAYLKt2lV5G8D1zF3RNmg=
github.com/ysmood/leakless v0.8.0/go.mod h1:R8iAXPRaG97QJwqxs74RdwzcRHT1SWCGTNqY8q0JvMQ=
github.com/ysmood/leakless v0.9.0 h1:qxCG5VirSBvmi3uynXFkcnLMzkphdh3xx5FtrORwDCU=
github.com/ysmood/leakless v0.9.0/go.mod h1:R8iAXPRaG97QJwqxs74RdwzcRHT1SWCGTNqY8q0JvMQ=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.26.0 h1:KHjCJyddX0LoSTb3J+vWpupP9p0oznkqVk/IfjymZbo=
golang.org/x/sys v0.26.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/text v0.20.0 h1:gK/Kv2otX8gz+wn7Rmb3vT96ZwuoxnQlY+HlJVj7Qug=
golang.org/x/text v0.20.0/go.mod h1:D4IsuqiFMhST5bX19pQ9ikHC2GsaKyk/oF+pn3ducp4=
gorm.io/driver/mysql v1.5.7 h1:MndhOPYOfEp2rHKgkZIhJ16eVUIRf2HmzgoPmh7FCWo=
gorm.io/driver/mysql v1.5.7/go.mod h1:sEtPWMiqiN1N1cMXoXmBbd8C6/l+TESwriotuRRpkDM=
gorm.io/gorm v1.25.7/go.mod h1:hbnx/Oo0ChWMn1BIhpy1oYozzpM15i4YPuHDmfYtwg8=
gorm.io/gorm v1.25.12 h1:I0u8i2hWQItBq1WfE0o2+WuL9+8L21K9e2HHSTE/0f8=
gorm.io/gorm v1.25.12/go.mod h1:xh7N7RHfYlNc5EmcI/El95gXusucDrQnHXe0+CgWcLQ=
