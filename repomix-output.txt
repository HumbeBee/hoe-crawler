This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-05T14:44:31.277Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.gitignore
cmd/config/config.go
cmd/list/main.go
go.mod
internal/models/hoe.go
internal/models/reporter.go
internal/sites/gaito/detail.go
internal/sites/gaito/list.go
internal/sites/gaito/report.go
internal/sites/gaito/scraper.go
internal/sites/gaito/selectors.go
internal/utils/browser/element.go
internal/utils/browser/rate_limit.go
internal/utils/browser/retry.go
internal/utils/common.go
main.go

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# Binaries for programs and plugins
*.exe
*.dll
*.so
*.dylib

# Output files
*.out

# Test binary
*.test

# Build directory
/build/
bin/

# Vendor directory (if not using Go modules)
vendor/

# IDE specific files
.idea/
.vscode/
*.swp

# Logs and temporary files
*.log
*.tmp
*.cache
*.env

# Go mod cache
go.sum

# Git specific files
.DS_Store

================
File: cmd/config/config.go
================
package config

import "log"

const (
	BaseUrl          = "https://www.gaito.love"
	RequestPerSecond = 1.0
)

// InitLogger configures the standard logger with:
// - Date and time (2006/01/02 15:04:05)
// - File name and line number (file.go:123)
// This helps with debugging by showing exactly where and when each log occurred
func InitLogger() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)
}

================
File: cmd/list/main.go
================
package main

import (
	"log"

	"github.com/haovoanh28/gai-webscraper/cmd/config"
	"github.com/haovoanh28/gai-webscraper/internal/sites/gaito"
)

func main() {
	config.InitLogger()

	log.Println("Starting URL list scraper ...")

	scraper := gaito.NewScraper(config.BaseUrl, config.RequestPerSecond)

	urls := scraper.GetList()
}

================
File: go.mod
================
module github.com/haovoanh28/gai-webscraper

go 1.23

toolchain go1.23.2

require (
	github.com/chromedp/cdproto v0.0.0-20241014181340-cb3a7a1d51d7
	github.com/chromedp/chromedp v0.11.0
)

require (
	github.com/chromedp/sysutil v1.1.0 // indirect
	github.com/go-rod/rod v0.116.2 // indirect
	github.com/gobwas/httphead v0.1.0 // indirect
	github.com/gobwas/pool v0.2.1 // indirect
	github.com/gobwas/ws v1.4.0 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/ysmood/fetchup v0.2.3 // indirect
	github.com/ysmood/goob v0.4.0 // indirect
	github.com/ysmood/got v0.40.0 // indirect
	github.com/ysmood/gson v0.7.3 // indirect
	github.com/ysmood/leakless v0.9.0 // indirect
	golang.org/x/sys v0.26.0 // indirect
)

================
File: internal/models/hoe.go
================
package models

import "fmt"

type HoeInfo struct {
	ID         string   `json:"id"`
	Url        string   `json:"url"`
	Name       string   `json:"name"`
	ImageUrl   string   `json:"image_url"`
	Price      string   `json:"price"`
	Phone      string   `json:"phone"`
	Address    string   `json:"address"`
	Author     string   `json:"author"`
	Status     string   `json:"status"`
	BirthYear  string   `json:"birth_year"`
	Height     string   `json:"height"`
	Weight     string   `json:"weight"`
	From       string   `json:"from"`
	Service    string   `json:"service"`
	Duration   string   `json:"duration"`
	WorkTime   string   `json:"work_time"`
	ReportURLs []string `json:"report_urls"`
}

type HoeReportInfo struct {
	ID          string    `json:"id"`
	DetailUrl   string    `json:"detail_url"`
	Rating      string    `json:"rating"`
	Author      *Reporter `json:"author"`
	Time        string    `json:"time"`
	Description string    `json:"description"`
}

func (hoe *HoeInfo) Print() {
	fmt.Printf("=========== Hoe %s ===========\n", hoe.ID)
	fmt.Printf("Url: %s\n", hoe.Url)

	// Print all fields in Main info
	fmt.Printf("Name: %s\n", hoe.Name)
	fmt.Printf("Image url: %s\n", hoe.ImageUrl)
	fmt.Printf("Price: %s\n", hoe.Price)
	fmt.Printf("Phone: %s\n", hoe.Phone)
	fmt.Printf("Address: %s\n", hoe.Address)
	fmt.Printf("Author: %s\n", hoe.Author)
	fmt.Printf("Status: %s\n", hoe.Status)
	fmt.Printf("Birth year: %s\n", hoe.BirthYear)
	fmt.Printf("Height: %s\n", hoe.Height)
	fmt.Printf("Weight: %s\n", hoe.Weight)
	fmt.Printf("From: %s\n", hoe.From)
	fmt.Printf("Service: %s\n", hoe.Service)
	fmt.Printf("Duration: %s\n", hoe.Duration)

	fmt.Println("==============================")
	fmt.Print("\n\n")
}

================
File: internal/models/reporter.go
================
package models

type Reporter struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	Url  string `json:"url"`
}

================
File: internal/sites/gaito/detail.go
================
package gaito

import (
	"fmt"
	"strings"
	"time"

	"github.com/go-rod/rod"
	"github.com/haovoanh28/gai-webscraper/internal/models"
	"github.com/haovoanh28/gai-webscraper/internal/utils"
	"github.com/haovoanh28/gai-webscraper/internal/utils/browser"
)

func ProcessDetailUrl(url string) *models.HoeInfo {
	defer func() {
		if err := recover(); err != nil {
			fmt.Printf("Error processing detail URL %s: %v\n", url, err)
		}
	}()

	result := ProcessDetailPage(url)
	return &result
}

func ProcessDetailPage(detailUrl string) models.HoeInfo {
	url := BaseUrl + detailUrl

	id := utils.GetIDFromUrl(detailUrl)

	// Wait until content element is visible
	page := rod.New().MustConnect().MustPage(url)
	containerElement := page.MustElement(`.container.seduction-container .ow_page_container`).MustWaitVisible()
	detailInfoElement := page.MustElement(`.tab-content`).MustWaitVisible()

	hoeInfo := models.HoeInfo{
		Url: url,
		ID:  id,
	}

	hoeInfo.Name = browser.GetElementsText(containerElement, `body > div.container.seduction-container > div.knn_page_wrap > div.ow_page_padding > div > div > div > div > div > div:nth-child(3) > div > h1`, "name")
	hoeInfo.ImageUrl = browser.GetElementAttribute(containerElement, `body > div.container.seduction-container > div.knn_page_wrap > div.ow_page_padding > div > div > div > div > div > div:nth-child(3) > div > div:nth-child(3) > div > div > div > div.tab-pane.ng-scope.active > div.jumbotron.ng-scope > div > div.col-md-3.col-sm-4.media.escort_item_wrap > div > image-placeholder > img`, "src", "image_url")
	// Ex: "300 k" => "300k"
	price := browser.GetElementText(detailInfoElement, `.jumbotron .fa.fa-money + span`, "price")
	hoeInfo.Price = strings.ReplaceAll(price, "\u00A0", "")
	// Ex: "0123.456.789" -> "0123456789"
	phone := browser.GetElementText(detailInfoElement, `.jumbotron .fa.fa-phone + a`, "phone")
	hoeInfo.Phone = strings.ReplaceAll(phone, ".", "")
	hoeInfo.Address = browser.GetElementText(detailInfoElement, `.jumbotron .fa.fa-map-marker + a`, "address")
	hoeInfo.Author = browser.GetElementText(detailInfoElement, `.jumbotron .fa.fa-user + a`, "author")
	hoeInfo.Status = browser.GetElementText(detailInfoElement, `.jumbotron .fa.fa-file-o + span`, "status")

	detailInfoElement = page.MustElement(`product-attribute .table-responsive`).MustWaitVisible()
	time.Sleep(2 * time.Second)
	hoeInfo.BirthYear = browser.GetElementText(detailInfoElement, `body > div.container.seduction-container > div.knn_page_wrap > div.ow_page_padding > div > div > div > div > div > div:nth-child(3) > div > div:nth-child(3) > div > div > div > div.tab-pane.ng-scope.active > div:nth-child(2) > product-attribute > div > div > div > table > tbody > tr:nth-child(3) > td:nth-child(2) > attribute-dob-box > div > div`, "birth_year")
	hoeInfo.Height = browser.GetElementText(detailInfoElement, `product-attribute table > tbody > tr:nth-child(4) > td:nth-child(2) > attribute-number-box .ng-scope`, "height") + "cm"
	hoeInfo.Weight = browser.GetElementText(detailInfoElement, `product-attribute table > tbody > tr:nth-child(5) > td:nth-child(2) > attribute-number-box .ng-scope`, "weight") + "kg"
	hoeInfo.From = browser.GetElementsText(detailInfoElement, `product-attribute table > tbody > tr:nth-child(9) > td:nth-child(2) > attribute-radio-box span span[ng-repeat="item in attributeDto.settings.values"]`, "from")
	hoeInfo.Service = browser.GetElementsText(detailInfoElement, `product-attribute table > tbody > tr:nth-child(12) > td:nth-child(2) > attribute-choices-box span span[ng-repeat="item in attributeDto.settings.values"]`, "service")
	hoeInfo.Duration = browser.GetElementText(detailInfoElement, `product-attribute table > tbody > tr:nth-child(15) > td:nth-child(2) > attribute-text-box span`, "duration")
	hoeInfo.WorkTime = browser.GetElementText(detailInfoElement, `product-attribute table > tbody > tr:nth-child(16) > td:nth-child(2) > attribute-text-box span`, "work_time")

	// Get report urls
	var reportUrls []string
	page.MustElement(`li[index="2"] a.nav-link`).MustClick().MustWaitLoad()
	time.Sleep(1 * time.Second)
	reportTabElement := page.MustElement(`product-review[ng-if="reviewTabLoaded"]`)

	for {
		reportElements, err := reportTabElement.Elements(`div[ng-repeat="review in reviews"]`)
		if err != nil {
			panic(err)
		}
		if len(reportElements) == 0 && len(reportUrls) == 0 {
			continue
			// panic(fmt.Errorf("empty reportElements ?: %v", err))
		}

		for _, reportElement := range reportElements {
			btnElement, err := reportElement.Element(`a.view_more_report`)
			if err != nil {
				panic(fmt.Errorf("failed to get view_more_report: %v", err))
			}

			reportUrl, err := btnElement.Attribute("href")
			if err != nil {
				panic(fmt.Errorf("failed to get reportUrl: %v", err))
			}
			reportUrls = append(reportUrls, *reportUrl)
		}

		if len(reportUrls) == 0 {
			break
		}

		goNextPageBtn, err := page.Timeout(1 * time.Second).Element(`product-review li.pagination-next:not(.disabled) a[ng-click]`)
		if err != nil {
			break
		} else {
			goNextPageBtn.MustClick().MustWaitLoad().CancelTimeout()
			time.Sleep(1 * time.Second)
		}
	}

	return hoeInfo
}

================
File: internal/sites/gaito/list.go
================
package gaito

import (
	"fmt"
	"time"

	"github.com/go-rod/rod"
)

func (s *Scraper) processListPage() ([]string, error) {
	const (
		itemThreshold = 30
	)

	url := s.baseURL + "/gai-goi/khu-vuc/Hồ%20Chí%20Minh/Quận%207"
	var urlList []string
	page := rod.New().Timeout(30 * time.Second).MustConnect().MustPage(url).MustWaitStable()
	defer page.Close()

	fmt.Println("Loading...", page.MustInfo())

	for {
		items := page.MustElements(listPageSelectors.Items)
		currentLength := len(items)

		// currentLength >= itemThreshold: enough items
		// currentLength == 0: for some reason, the query doesn't return any items (Ex: Cloudflare, ...)
		if currentLength >= itemThreshold || currentLength == 0 {
			break
		}

		loadMoreBtn := page.MustElement(listPageSelectors.LoadMoreBtn)
		loadMoreBtn.MustClick()

		page.MustWaitElementsMoreThan(listPageSelectors.Items, currentLength)
	}

	elements := page.MustElements(listPageSelectors.Items)
	fmt.Println("Found", len(elements), "items")
	for _, elem := range elements {
		urlList = append(urlList, *elem.MustElement(listPageSelectors.ThumbnailUrl).MustAttribute("href"))
	}

	return urlList, nil
}

================
File: internal/sites/gaito/report.go
================
package gaito

import (
	"fmt"
	"strconv"

	"github.com/go-rod/rod"
	"github.com/haovoanh28/gai-webscraper/internal/models"
	"github.com/haovoanh28/gai-webscraper/internal/utils"
	"github.com/haovoanh28/gai-webscraper/internal/utils/browser"
)

func ProcessReportPage(reportUrl string) models.HoeReportInfo {
	url := BaseUrl + reportUrl
	id := utils.GetIDFromUrl(reportUrl)

	reportInfo := models.HoeReportInfo{
		ID:        id,
		DetailUrl: reportUrl,
	}

	page := rod.New().MustConnect().MustPage(url).MustWaitStable()
	element := page.MustElement(`review-detail-cmp`).MustWaitVisible()
	defer page.Close()

	stars, err := page.Elements(`span[ng-model="data.review.score"] i.fa-heart[ng-repeat="r in range track by $index"]`)
	if err != nil {
		panic(fmt.Errorf(`failed to get stars: %v`, err))
	}
	reportInfo.Rating = strconv.Itoa(len(stars))

	reportInfo.Description = browser.GetElementText(element, `div[ng-switch-when="textarea"] span[ng-bind="elem.question.response"]`, id+"_report_description")

	// Process author
	authorSectionElement, err := page.Element(`div.ow_page_padding > div > div > div > div > div > div:nth-child(3) > div > div.col-md-4 > div:nth-child(2) > div > div.ow_user_list_data`)
	if err != nil {
		panic(fmt.Errorf(`failed to get author section: %v`, err))
	}
	authorUrlElement := authorSectionElement.MustElement(`a.ng-binding`)
	authorUrl := authorUrlElement.MustAttribute(`href`)
	reportInfo.Author = &models.Reporter{
		ID:   utils.GetIDFromUrl(*authorUrl),
		Name: authorUrlElement.MustText(),
		Url:  *authorUrl,
	}
	reportInfo.Time = browser.GetElementText(element, `div.ow_page_padding > div > div > div > div > div > div:nth-child(3) > div > div.col-md-8 > review-detail-cmp > div:nth-child(1) > em > small`, id+"_report_time")

	return reportInfo
}

================
File: internal/sites/gaito/scraper.go
================
package gaito

import "github.com/haovoanh28/gai-webscraper/internal/models"

type Scraper struct {
	baseURL        string
	requestsPerSec float64
}

func NewScraper(baseURL string, requestsPerSec float64) *Scraper {
	return &Scraper{baseURL: baseURL, requestsPerSec: requestsPerSec}
}

func (s *Scraper) GetList() []string {
	return s.processListPage()
}

func (s *Scraper) GetDetail(url string) *models.HoeInfo {
	result := ProcessDetailPage(url)
	return &result
}

================
File: internal/sites/gaito/selectors.go
================
package gaito

// ListPageSelectors contains all selectors used in list page scraping
type ListPageSelectors struct {
	Items        string
	LoadMoreBtn  string
	ThumbnailUrl string
}

var (
	listPageSelectors = ListPageSelectors{
		Items:        `div[ng-repeat="item in products"]`,
		LoadMoreBtn:  `body > div.container.seduction-container > div.knn_page_wrap > div.ow_page_padding > div > div > div > div > div > div:nth-child(3) > div:nth-child(4) > div > button`,
		ThumbnailUrl: `.thumbnail a`,
	}
)

================
File: internal/utils/browser/element.go
================
package browser

import (
	"strings"

	"github.com/go-rod/rod"
	"github.com/haovoanh28/gai-webscraper/internal/utils"
)

func GetElementWithRetry(rodElement *rod.Element, selector string, fieldName string) (*rod.Element, error) {
	return retryRodElement(func() (*rod.Element, error) {
		return rodElement.Element(selector)
	}, fieldName)
}

func GetElementText(rodElement *rod.Element, selector string, fieldName string) string {
	// element, err := rodElement.Element(selector)
	element, err := GetElementWithRetry(rodElement, selector, fieldName)
	utils.HandleError(err, "get element", fieldName)

	err = element.WaitVisible()
	utils.HandleError(err, "wait visible", fieldName)

	text, err := element.Text()
	utils.HandleError(err, "get text", fieldName)

	return strings.TrimSpace(text)
}

func GetElementAttribute(rodElement *rod.Element, selector string, attributeName string, fieldName string) string {
	element, err := GetElementWithRetry(rodElement, selector, fieldName)
	utils.HandleError(err, "get element", fieldName)

	attribute, err := element.Attribute(attributeName)
	utils.HandleError(err, "get attribute", fieldName)

	return *attribute
}

func GetElementsText(rodElement *rod.Element, selector string, fieldName string) string {
	elements, err := rodElement.Elements(selector)
	utils.HandleError(err, "get elements", fieldName)

	var texts []string
	for _, element := range elements {
		text, err := element.Text()
		utils.HandleError(err, "get text", fieldName)

		text = strings.TrimSpace(text)
		if text != "" {
			texts = append(texts, text)
		}
	}

	return strings.Join(texts, ", ")
}

================
File: internal/utils/browser/rate_limit.go
================
package browser

import "time"

type RateLimiter struct {
	interval time.Duration
	ticker   *time.Ticker
}

func NewRateLimiter(requestsPerSecond float64) *RateLimiter {
	interval := time.Duration(1000/requestsPerSecond) * time.Millisecond
	return &RateLimiter{
		interval: interval,
		ticker:   time.NewTicker(interval),
	}
}

func (r *RateLimiter) Wait() {
	<-r.ticker.C
}

================
File: internal/utils/browser/retry.go
================
package browser

import (
	"fmt"
	"time"

	"github.com/go-rod/rod"
)

func retryRodElement[T any](operation func() (T, error), fieldName string) (T, error) {
	maxAttempts := 20
	interval := 500 * time.Millisecond

	for attempt := 0; attempt < maxAttempts; attempt++ {
		result, err := operation()
		if err == nil {
			if slice, ok := any(result).([]*rod.Element); ok { // Check for multiple elements
				if len(slice) > 0 {
					return result, nil
				}
			} else if elem, ok := any(result).(*rod.Element); ok { // Check for single element
				if elem != nil {
					if visible, _ := elem.Visible(); visible {
						return result, nil
					}
				}
			}
		}
		time.Sleep(interval)
	}

	var zero T
	return zero, fmt.Errorf("failed to execute operation %s after %d attempts", fieldName, maxAttempts)
}

================
File: internal/utils/common.go
================
package utils

import (
	"fmt"
	"regexp"
	"strings"
)

func GetIDFromUrl(url string) string {
	url = strings.TrimSuffix(url, "/")

	// Pattern 1: "/x/y/id/z" - extract ID between segments
	re1 := regexp.MustCompile(`/([^/]+)/[^/]+$`)
	if match := re1.FindStringSubmatch(url); len(match) >= 2 {
		return match[1]
	}

	// Pattern 2: "/a/id" - extract ID at the end
	re2 := regexp.MustCompile(`/([^/]+)$`)
	if match := re2.FindStringSubmatch(url); len(match) >= 2 {
		return match[1]
	}

	return ""
}

func HandleError(err error, operation string, fieldName string) {
	if err != nil {
		panic(fmt.Errorf(`failed to %s "%s": %v`, operation, fieldName, err))
	}
}

================
File: main.go
================
package main

import (
	"fmt"
	"sync"

	"github.com/haovoanh28/gai-webscraper/internal/models"
	"github.com/haovoanh28/gai-webscraper/internal/sites/gaito"
	"github.com/haovoanh28/gai-webscraper/internal/utils/browser"
)

func main() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(err)
		}
	}()

	urlList := gaito.ProcessListPage()

	rateLimiter := browser.NewRateLimiter(1.0)
	urlChan := make(chan string, len(urlList))
	resultChan := make(chan models.HoeInfo, len(urlList))
	var wg sync.WaitGroup

	numWorkers := 2
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for url := range urlChan {
				// Wait for rate limiter before making request
				rateLimiter.Wait()

				if result := gaito.ProcessDetailUrl(url); result != nil {
					fmt.Println("Processed", url)
					resultChan <- *result
				}
			}
		}()
	}

	go func() {
		wg.Wait()
		close(resultChan)
	}()

	// Test for first 4 item
	for _, url := range urlList {
		urlChan <- url
	}
	close(urlChan)

	var hoeList []models.HoeInfo
	for hoe := range resultChan {
		hoeList = append(hoeList, hoe)
	}

	for _, hoe := range hoeList {
		hoe.Print()

		if len(hoe.ReportURLs) > 0 {
			// Process report url or put it into db ???
		}
	}

}
