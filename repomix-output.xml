This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-04T08:59:51.863Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
cmd/
  detail/
    main.go
  list/
    main.go
  migrate/
    main.go
internal/
  config/
    env.go
  definitions/
    config.go
    hoe.go
    service.go
  dto/
    hoe_dto.go
  infrastructure/
    browser/
      roddriver/
        browser.go
        bypass.go
        element.go
        page.go
        retry.go
      connect.go
      factory.go
      rate_limit.go
    cloudflare/
      factory.go
      yoori_bypasser.go
    database/
      connection.go
      migrate.go
      seed_default_data.go
      types.go
    interfaces/
      browser.go
      cloudflare.go
  interfaces/
    scraper.go
  models/
    city.go
    district.go
    hoe_profile.go
    hoe_report.go
    hoe.go
    hotel.go
    reporter.go
    site.go
    street.go
    working_history.go
  repository/
    hoe.go
    location.go
    site.go
    working_history.go
  scrapers/
    gaito/
      detail.go
      list.go
      report.go
      scraper.go
      selectors.go
    factory.go
  service/
    hoe_builder.go
    hoe.go
    mapper.go
    validate.go
  utils/
    errutil/
      handler.go
    logutil/
      handler.go
      level.go
    setuputil/
      setup.go
    common.go
.env.example
.gitignore
docker-compose.yml
go.mod
go.sum
README.md
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="cmd/detail/main.go">
package main

import (
	"github.com/HumbeBee/hoe-crawler/internal/utils/setuputil"
)

func main() {
	appContext, err := setuputil.CreateAppContext()
	if err != nil {
		panic(err)
	}

	// Example url
	url := "/gai-goi/chi-tiet/56042/hot-girl-diep-anhmat-xinh-nguc-dep-bu-cu-dieu-luyen"

	err = appContext.HoeService.ProcessDetailPage(url)
	if err != nil {
		appContext.Logger.Fatal(err.Error())
	}
}
</file>

<file path="cmd/list/main.go">
package main

import (
	"github.com/HumbeBee/hoe-crawler/internal/utils/setuputil"
)

func main() {
	appContext, err := setuputil.CreateAppContext()
	if err != nil {
		panic(err)
	}

	err = appContext.HoeService.ProcessListPage()
	if err != nil {
		appContext.Logger.Fatal(err.Error())
	}
}
</file>

<file path="cmd/migrate/main.go">
package main

import "github.com/HumbeBee/hoe-crawler/internal/infrastructure/database"

func main() {
	db, err := database.InitDB()
	if err != nil {
		panic(err)
	}

	if err := database.Migrate(db); err != nil {
		panic(err)
	}

	if err := database.SeedDefaultData(db); err != nil {
		panic(err)
	}
}
</file>

<file path="internal/config/env.go">
package config

import (
	"github.com/joho/godotenv"
	"os"
	"sync"
)

type EnvConfig struct {
	// Database
	DBHost     string `env:"DB_HOST"`
	DBPort     string `env:"DB_PORT"`
	DBUser     string `env:"DB_USER"`
	DBPassword string `env:"DB_PASSWORD"`
	DBName     string `env:"DB_NAME"`
}

var (
	envConfig *EnvConfig
	once      sync.Once
)

func GetEnvConfig() *EnvConfig {
	once.Do(func() {
		if err := godotenv.Load(); err != nil {
			panic(err)
		}

		envConfig = &EnvConfig{
			DBHost:     os.Getenv("DB_HOST"),
			DBPort:     os.Getenv("DB_PORT"),
			DBUser:     os.Getenv("DB_USER"),
			DBPassword: os.Getenv("DB_PASSWORD"),
			DBName:     os.Getenv("DB_NAME"),
		}
	})
	return envConfig
}
</file>

<file path="internal/definitions/config.go">
package definitions

import (
	"github.com/HumbeBee/hoe-crawler/internal/utils/logutil"
)

type ScraperConfig struct {
	SiteID            uint
	SiteName          string
	BaseURL           string
	RequestsPerSecond float64
	Logger            *logutil.Logger
}
</file>

<file path="internal/definitions/hoe.go">
package definitions

type ParsedAddress struct {
	Street   string
	District string
}
</file>

<file path="internal/definitions/service.go">
package definitions

import (
	"github.com/HumbeBee/hoe-crawler/internal/dto"
	"github.com/HumbeBee/hoe-crawler/internal/models"
)

type MapperService interface {
	TransformHoe(rawInfo *dto.RawHoeData) *models.HoeInfo
}

type ValidateService interface {
	ValidateHoe(hoe *models.HoeInfo) error
}
</file>

<file path="internal/dto/hoe_dto.go">
package dto

type RawHoeData struct {
	SiteID   uint
	OriginID string
	Url      string

	// All scraped fields without transformation
	CityName     string
	DistrictName string
	Name         string
	ImageUrl     string
	Price        string
	Phone        string
	Area         string
	Provider     string
	Status       string
	BirthYear    string
	Height       string
	Weight       string
	Country      string
	Service      string
	Duration     string
	WorkTime     string
}
</file>

<file path="internal/infrastructure/browser/roddriver/browser.go">
package roddriver

import (
	"time"

	"github.com/HumbeBee/hoe-crawler/internal/infrastructure/interfaces"
	"github.com/go-rod/rod"
	"github.com/go-rod/stealth"
)

type rodBrowser struct {
	browser *rod.Browser
}

func (rb *rodBrowser) Connect() error {
	if err := rb.browser.Connect(); err != nil {
		return err
	}

	return nil
}

func (rb *rodBrowser) Close() {
	rb.browser.Close()
}

func (rb *rodBrowser) CreatePage() (interfaces.Page, error) {
	page, err := stealth.Page(rb.browser)
	if err != nil {
		return nil, err
	}

	return &rodPage{page: page}, nil
}

// Return rodBrowser, if later uses another library, consider using a factory pattern
func NewBrowser(timeout time.Duration) interfaces.Browser {
	return &rodBrowser{browser: rod.New().Timeout(timeout)}
}
</file>

<file path="internal/infrastructure/browser/roddriver/bypass.go">
package roddriver

import "github.com/HumbeBee/hoe-crawler/internal/infrastructure/cloudflare"

func (b *rodBrowser) BypassCloudflare(url string) error {
	cloudflareBypasser := cloudflare.NewBypasser("yoori")
	cloudflareBypasser.GetCookies(url)

	return nil
}
</file>

<file path="internal/infrastructure/browser/roddriver/element.go">
package roddriver

import (
	"strings"

	"github.com/HumbeBee/hoe-crawler/internal/infrastructure/interfaces"
	"github.com/go-rod/rod"
	"github.com/go-rod/rod/lib/proto"
)

type rodElement struct {
	element *rod.Element
}

// *Return rodElement, if later uses another library, consider using a factory pattern
func NewElement(element *rod.Element) interfaces.Element {
	return &rodElement{element: element}
}

func (re *rodElement) getElementWithRetry(selector string) (*rod.Element, error) {
	return retryRodElement(func() (*rod.Element, error) {
		return re.element.Element(selector)
	})
}

func (re *rodElement) getMultipleElementsWithRetry(selector string) ([]*rod.Element, error) {
	return retryRodElement(func() ([]*rod.Element, error) {
		return re.element.Elements(selector)
	})
}

// Implementing Element interface
func (re *rodElement) Find(selector string) (interfaces.Element, error) {
	elem, err := re.getElementWithRetry(selector)
	if err != nil {
		return nil, err
	}
	return NewElement(elem), nil
}

func (re *rodElement) FindAll(selector string) ([]interfaces.Element, error) {
	elems, err := re.getMultipleElementsWithRetry(selector)
	if err != nil {
		return nil, err
	}

	elements := make([]interfaces.Element, len(elems))
	for i, elem := range elems {
		elements[i] = NewElement(elem)
	}
	return elements, nil
}

func (re *rodElement) GetText() (string, error) {
	text, err := re.element.Text()
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(text), nil
}

func (re *rodElement) GetAttribute(name string) (string, error) {
	attr, err := re.element.Attribute(name)
	if err != nil {
		return "", err
	}
	if attr == nil {
		return "", nil
	}
	return *attr, nil
}

func (re *rodElement) Click() error {
	return re.element.Click(proto.InputMouseButtonLeft, 1)
}

func (re *rodElement) WaitVisible() error {
	return re.element.WaitVisible()
}

// Must versions that panic on error
func (re *rodElement) MustFind(selector string) interfaces.Element {
	elem, err := re.Find(selector)
	if err != nil {
		panic(err)
	}
	return elem
}

func (re *rodElement) MustGetText() string {
	text, err := re.GetText()
	if err != nil {
		panic(err)
	}
	return text
}

func (re *rodElement) MustGetAttribute(name string) string {
	attr, err := re.GetAttribute(name)
	if err != nil {
		panic(err)
	}
	return attr
}
</file>

<file path="internal/infrastructure/browser/roddriver/page.go">
package roddriver

import (
	"time"

	"github.com/HumbeBee/hoe-crawler/internal/infrastructure/interfaces"
	"github.com/go-rod/rod"
)

type rodPage struct {
	page *rod.Page
}

func (rp *rodPage) Navigate(url string) error {
	return rp.page.Navigate(url)
}

func (rp *rodPage) WaitStable(timeout time.Duration) error {
	return rp.page.WaitStable(timeout)
}

func (rp *rodPage) GetRootElement() interfaces.Element {
	return NewElement(rp.page.MustElement("html"))
}

func (rp *rodPage) Close() {
	rp.page.Close()
}

func (rp *rodPage) WaitElementsMoreThan(selector string, count int) error {
	return rp.page.WaitElementsMoreThan(selector, count)
}
</file>

<file path="internal/infrastructure/browser/roddriver/retry.go">
package roddriver

import (
	"time"

	"github.com/go-rod/rod"
)

func retryRodElement[T any](operation func() (T, error)) (T, error) {
	maxAttempts := 20
	interval := 500 * time.Millisecond

	var lastErr error
	for attempt := 0; attempt < maxAttempts; attempt++ {
		result, err := operation()
		if err == nil {
			if slice, ok := any(result).([]*rod.Element); ok { // Check for multiple elements
				if len(slice) > 0 {
					return result, nil
				}
			} else if elem, ok := any(result).(*rod.Element); ok { // Check for single element
				if elem != nil {
					if visible, _ := elem.Visible(); visible {
						return result, nil
					}
				}
			}
		}
		lastErr = err
		time.Sleep(interval)
	}

	var zero T
	return zero, lastErr
}
</file>

<file path="internal/infrastructure/browser/connect.go">
package browser

import (
	"time"

	"github.com/HumbeBee/hoe-crawler/internal/infrastructure/interfaces"
)

type Connection struct {
	Browser interfaces.Browser
	Page    interfaces.Page
	Root    interfaces.Element
}

func (c *Connection) Close() {
	if c.Browser != nil {
		c.Browser.Close()
	}
	if c.Page != nil {
		c.Page.Close()
	}
}

func ConnectToPage(url string, timeout time.Duration) (*Connection, error) {
	browser := NewBrowser(RodDriver, timeout)
	if err := browser.Connect(); err != nil {
		return nil, err
	}

	err := browser.BypassCloudflare(url)
	if err != nil {
		return nil, err
	}

	page, err := browser.CreatePage()
	if err != nil {
		return nil, err
	}

	if err := page.Navigate(url); err != nil {
		return nil, err
	}

	if err := page.WaitStable(time.Duration(30)); err != nil {
		return nil, err
	}

	root := page.GetRootElement()
	if err := root.WaitVisible(); err != nil {
		page.Close()
		browser.Close()
		return nil, err
	}

	return &Connection{Browser: browser, Page: page, Root: root}, nil
}
</file>

<file path="internal/infrastructure/browser/factory.go">
package browser

import (
	"time"

	"github.com/HumbeBee/hoe-crawler/internal/infrastructure/browser/roddriver"
	"github.com/HumbeBee/hoe-crawler/internal/infrastructure/interfaces"
)

type DriverType string

const (
	RodDriver DriverType = "rod"
	// Future drivers can be added here
	// SeleniumDriver DriverType = "selenium"
)

// NewBrowser creates a new browser instance based on the driver type
func NewBrowser(driverType DriverType, timeout time.Duration) interfaces.Browser {
	switch driverType {
	case RodDriver:
		return roddriver.NewBrowser(timeout)
	default:
		// For now, default to Rod
		return roddriver.NewBrowser(timeout)
	}
}
</file>

<file path="internal/infrastructure/browser/rate_limit.go">
package browser

import "time"

type RateLimiter struct {
	interval time.Duration
	ticker   *time.Ticker
}

func NewRateLimiter(requestsPerSecond float64) *RateLimiter {
	interval := time.Duration(1000/requestsPerSecond) * time.Millisecond
	return &RateLimiter{
		interval: interval,
		ticker:   time.NewTicker(interval),
	}
}

func (r *RateLimiter) Wait() {
	<-r.ticker.C
}
</file>

<file path="internal/infrastructure/cloudflare/factory.go">
package cloudflare

import "github.com/HumbeBee/hoe-crawler/internal/infrastructure/interfaces"

// internal/infrastructure/cloudflare/factory.go
func NewBypasser(bypasserType string) interfaces.CloudflareBypasser {
	switch bypasserType {
	case "yoori":
		return newYooriBypasser()
	default:
		return nil
	}
}
</file>

<file path="internal/infrastructure/cloudflare/yoori_bypasser.go">
package cloudflare

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/HumbeBee/hoe-crawler/internal/infrastructure/interfaces"
)

type yooriBypasser struct {
	baseUrl  string
	basePort int
	client   *http.Client
}

func newYooriBypasser() interfaces.CloudflareBypasser {
	return &yooriBypasser{
		baseUrl:  "http://localhost",
		basePort: 20080,
		client: &http.Client{
			Timeout: 60 * time.Second,
		},
	}
}

func (y *yooriBypasser) GetCookies(url string) ([]byte, error) {
	endpoint := fmt.Sprintf("%s:%d/v1", y.baseUrl, y.basePort)

	data := map[string]interface{}{
		"cmd":        "request.get",
		"url":        url,
		"maxTimeout": 60000,
	}

	jsonData, err := json.Marshal(data)
	if err != nil {
		return nil, fmt.Errorf("error marshaling data: %v", err)
	}

	req, err := http.NewRequest(http.MethodPost, endpoint, bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := y.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error making request: %v", err)
	}
	defer resp.Body.Close()

	return io.ReadAll(resp.Body)
}
</file>

<file path="internal/infrastructure/database/connection.go">
package database

import (
	"fmt"

	"github.com/HumbeBee/hoe-crawler/internal/config"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

func InitDB() (*gorm.DB, error) {
	cfg := NewConfig()
	db, err := GetDB(cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %v", err)
	}

	return db, nil
}

func NewConfig() *DBConfig {
	envConfig := config.GetEnvConfig()

	return &DBConfig{
		Host:     envConfig.DBHost,
		Port:     envConfig.DBPort,
		User:     envConfig.DBUser,
		Password: envConfig.DBPassword,
		DBName:   envConfig.DBName,
	}
}

func (c *DBConfig) BuildConnectionString() string {
	return fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
		c.User, c.Password, c.Host, c.Port, c.DBName)
}

func GetDB(cfg *DBConfig) (*gorm.DB, error) {
	db, err := gorm.Open(mysql.Open(cfg.BuildConnectionString()), &gorm.Config{})
	if err != nil {
		return nil, err
	}

	return db, nil
}

func CloseDB(db *gorm.DB) error {
	sqlDB, err := db.DB()
	if err != nil {
		return err
	}

	return sqlDB.Close()
}
</file>

<file path="internal/infrastructure/database/migrate.go">
package database

import (
	"fmt"

	"github.com/HumbeBee/hoe-crawler/internal/models"
	"gorm.io/gorm"
)

func Migrate(db *gorm.DB) error {
	_models := []interface{}{
		&models.Site{},
		&models.City{},
		&models.District{},
		&models.Street{},
		&models.HoeInfo{},
		&models.HoeReport{},
		&models.WorkingHistory{},
	}

	for _, model := range _models {
		if err := db.AutoMigrate(model); err != nil {
			return fmt.Errorf("failed to migrate %T: %v", model, err)
		}
	}

	return nil
}
</file>

<file path="internal/infrastructure/database/seed_default_data.go">
package database

import (
	"fmt"

	"github.com/HumbeBee/hoe-crawler/internal/models"
	"gorm.io/gorm"
)

func SeedDefaultData(db *gorm.DB) error {
	if err := seedSites(db); err != nil {
		return err
	}

	if err := seedCities(db); err != nil {
		return err
	}

	return nil
}

func seedSites(db *gorm.DB) error {
	sites := []models.Site{
		{
			Name:      "gaito",
			BaseURL:   "https://gaito.so",
			IsExpired: false,
		},
		{
			Name:      "gaigu",
			BaseURL:   "https://gaigu31.tv",
			IsExpired: false,
		},
	}

	for _, site := range sites {
		result := db.Where(models.Site{Name: site.Name}).
			FirstOrCreate(&site)
		if result.Error != nil {
			return result.Error
		}
	}

	return nil
}

func seedCities(db *gorm.DB) error {
	cities := []models.City{
		{
			Name:        "Hồ Chí Minh",
			Code:        "HCM",
			DisplayName: "Thành phố Hồ Chí Minh",
			EngName:     "Ho Chi Minh City",
			Districts: []models.District{
				{Name: "Quận 1", ShortName: "Q1", Code: "Q1", DisplayName: "Quận 1", EngName: "District 1"},
				{Name: "Quận 2", ShortName: "Q2", Code: "Q2", DisplayName: "Quận 2", EngName: "District 2"},
				{Name: "Quận 3", ShortName: "Q3", Code: "Q3", DisplayName: "Quận 3", EngName: "District 3"},
				{Name: "Quận 4", ShortName: "Q4", Code: "Q4", DisplayName: "Quận 4", EngName: "District 4"},
				{Name: "Quận 5", ShortName: "Q5", Code: "Q5", DisplayName: "Quận 5", EngName: "District 5"},
				{Name: "Quận 6", ShortName: "Q6", Code: "Q6", DisplayName: "Quận 6", EngName: "District 6"},
				{Name: "Quận 7", ShortName: "Q7", Code: "Q7", DisplayName: "Quận 7", EngName: "District 7"},
				{Name: "Quận 8", ShortName: "Q8", Code: "Q8", DisplayName: "Quận 8", EngName: "District 8"},
				{Name: "Quận 9", ShortName: "Q9", Code: "Q9", DisplayName: "Quận 9", EngName: "District 9"},
				{Name: "Quận 10", ShortName: "Q10", Code: "Q10", DisplayName: "Quận 10", EngName: "District 10"},
				{Name: "Quận 11", ShortName: "Q11", Code: "Q11", DisplayName: "Quận 11", EngName: "District 11"},
				{Name: "Quận 12", ShortName: "Q12", Code: "Q12", DisplayName: "Quận 12", EngName: "District 12"},
				{Name: "Quận Bình Tân", ShortName: "BTN", Code: "BTN", DisplayName: "Quận Bình Tân", EngName: "Binh Tan District"},
				{Name: "Quận Bình Thạnh", ShortName: "BTH", Code: "BTH", DisplayName: "Quận Bình Thạnh", EngName: "Binh Thanh District"},
				{Name: "Quận Gò Vấp", ShortName: "GV", Code: "GV", DisplayName: "Quận Gò Vấp", EngName: "Go Vap District"},
				{Name: "Quận Phú Nhuận", ShortName: "PN", Code: "PN", DisplayName: "Quận Phú Nhuận", EngName: "Phu Nhuan District"},
				{Name: "Quận Tân Bình", ShortName: "TB", Code: "TB", DisplayName: "Quận Tân Bình", EngName: "Tan Binh District"},
				{Name: "Quận Tân Phú", ShortName: "TP", Code: "TP", DisplayName: "Quận Tân Phú", EngName: "Tan Phu District"},
				{Name: "Thành phố Thủ Đức", ShortName: "TD", Code: "TD", DisplayName: "Thành phố Thủ Đức", EngName: "Thu Duc City"},
				{Name: "Huyện Bình Chánh", ShortName: "BCH", Code: "BCH", DisplayName: "Huyện Bình Chánh", EngName: "Binh Chanh District"},
				{Name: "Huyện Cần Giờ", ShortName: "CG", Code: "CG", DisplayName: "Huyện Cần Giờ", EngName: "Can Gio District"},
				{Name: "Huyện Củ Chi", ShortName: "CC", Code: "CC", DisplayName: "Huyện Củ Chi", EngName: "Cu Chi District"},
				{Name: "Huyện Hóc Môn", ShortName: "HM", Code: "HM", DisplayName: "Huyện Hóc Môn", EngName: "Hoc Mon District"},
				{Name: "Huyện Nhà Bè", ShortName: "NB", Code: "NB", DisplayName: "Huyện Nhà Bè", EngName: "Nha Be District"},
			},
		},
		{
			Name:        "Hà Nội",
			Code:        "HN",
			DisplayName: "Thành phố Hà Nội",
			EngName:     "Hanoi",
			Districts: []models.District{
				{Name: "Ba Đình", ShortName: "BD", Code: "BD", DisplayName: "Quận Ba Đình", EngName: "Ba Dinh District"},
				{Name: "Hoàn Kiếm", ShortName: "HK", Code: "HK", DisplayName: "Quận Hoàn Kiếm", EngName: "Hoan Kiem District"},
				{Name: "Tây Hồ", ShortName: "TH", Code: "TH", DisplayName: "Quận Tây Hồ", EngName: "Tay Ho District"},
				{Name: "Long Biên", ShortName: "LB", Code: "LB", DisplayName: "Quận Long Biên", EngName: "Long Bien District"},
				{Name: "Cầu Giấy", ShortName: "CG", Code: "CG", DisplayName: "Quận Cầu Giấy", EngName: "Cau Giay District"},
				{Name: "Đống Đa", ShortName: "DD", Code: "DD", DisplayName: "Quận Đống Đa", EngName: "Dong Da District"},
				{Name: "Hai Bà Trưng", ShortName: "HBT", Code: "HBT", DisplayName: "Quận Hai Bà Trưng", EngName: "Hai Ba Trung District"},
				{Name: "Hoàng Mai", ShortName: "HM", Code: "HM", DisplayName: "Quận Hoàng Mai", EngName: "Hoang Mai District"},
				{Name: "Thanh Xuân", ShortName: "TX", Code: "TX", DisplayName: "Quận Thanh Xuân", EngName: "Thanh Xuan District"},
				{Name: "Sóc Sơn", ShortName: "SS", Code: "SS", DisplayName: "Huyện Sóc Sơn", EngName: "Soc Son District"},
				{Name: "Đông Anh", ShortName: "DA", Code: "DA", DisplayName: "Huyện Đông Anh", EngName: "Dong Anh District"},
				{Name: "Gia Lâm", ShortName: "GL", Code: "GL", DisplayName: "Huyện Gia Lâm", EngName: "Gia Lam District"},
				{Name: "Nam Từ Liêm", ShortName: "NTL", Code: "NTL", DisplayName: "Quận Nam Từ Liêm", EngName: "Nam Tu Liem District"},
				{Name: "Thanh Trì", ShortName: "TT", Code: "TT", DisplayName: "Huyện Thanh Trì", EngName: "Thanh Tri District"},
				{Name: "Bắc Từ Liêm", ShortName: "BTL", Code: "BTL", DisplayName: "Quận Bắc Từ Liêm", EngName: "Bac Tu Liem District"},
				{Name: "Mê Linh", ShortName: "ML", Code: "ML", DisplayName: "Huyện Mê Linh", EngName: "Me Linh District"},
				{Name: "Hà Đông", ShortName: "HD", Code: "HD", DisplayName: "Quận Hà Đông", EngName: "Ha Dong District"},
				{Name: "Sơn Tây", ShortName: "ST", Code: "ST", DisplayName: "Thị xã Sơn Tây", EngName: "Son Tay Town"},
				{Name: "Ba Vì", ShortName: "BV", Code: "BV", DisplayName: "Huyện Ba Vì", EngName: "Ba Vi District"},
				{Name: "Phúc Thọ", ShortName: "PT", Code: "PT", DisplayName: "Huyện Phúc Thọ", EngName: "Phuc Tho District"},
				{Name: "Đan Phượng", ShortName: "DP", Code: "DP", DisplayName: "Huyện Đan Phượng", EngName: "Dan Phuong District"},
				{Name: "Hoài Đức", ShortName: "HD", Code: "HD", DisplayName: "Huyện Hoài Đức", EngName: "Hoai Duc District"},
				{Name: "Quốc Oai", ShortName: "QO", Code: "QO", DisplayName: "Huyện Quốc Oai", EngName: "Quoc Oai District"},
				{Name: "Thạch Thất", ShortName: "TT", Code: "TT", DisplayName: "Huyện Thạch Thất", EngName: "Thach That District"},
				{Name: "Chương Mỹ", ShortName: "CM", Code: "CM", DisplayName: "Huyện Chương Mỹ", EngName: "Chuong My District"},
				{Name: "Thanh Oai", ShortName: "TO", Code: "TO", DisplayName: "Huyện Thanh Oai", EngName: "Thanh Oai District"},
				{Name: "Thường Tín", ShortName: "TT", Code: "TT", DisplayName: "Huyện Thường Tín", EngName: "Thuong Tin District"},
				{Name: "Phú Xuyên", ShortName: "PX", Code: "PX", DisplayName: "Huyện Phú Xuyên", EngName: "Phu Xuyen District"},
				{Name: "Ứng Hòa", ShortName: "UH", Code: "UH", DisplayName: "Huyện Ứng Hòa", EngName: "Ung Hoa District"},
				{Name: "Mỹ Đức", ShortName: "MD", Code: "MD", DisplayName: "Huyện Mỹ Đức", EngName: "My Duc District"},
			},
		},
	}

	for _, city := range cities {
		var existingCity models.City
		result := db.Where(models.City{Name: city.Name}).First(&existingCity)

		if result.Error != nil {
			// City doesn't exist, create new city with provinces
			if err := db.Create(&city).Error; err != nil {
				return fmt.Errorf("failed to create city %s: %v", city.Name, err)
			}
		} else {
			// City exists, check and create missing provinces
			for _, province := range city.Districts {
				province.CityID = existingCity.ID
				result := db.Where(models.District{
					Name:   province.Name,
					CityID: existingCity.ID,
				}).FirstOrCreate(&province)

				if result.Error != nil {
					return fmt.Errorf("failed to create province %s: %v", province.Name, result.Error)
				}
			}
		}
	}

	return nil
}
</file>

<file path="internal/infrastructure/database/types.go">
package database

type DBConfig struct {
	Host     string
	Port     string
	User     string
	Password string
	DBName   string
}
</file>

<file path="internal/infrastructure/interfaces/browser.go">
package interfaces

import "time"

type Browser interface {
	Connect() error
	BypassCloudflare(url string) error
	CreatePage() (Page, error)
	Close()
}

type Page interface {
	Navigate(url string) error
	WaitStable(timeout time.Duration) error
	WaitElementsMoreThan(selector string, count int) error
	GetRootElement() Element
	Close()
}

type Element interface {
	Find(selector string) (Element, error)
	FindAll(selector string) ([]Element, error)
	GetText() (string, error)
	GetAttribute(name string) (string, error)
	Click() error
	WaitVisible() error
	MustFind(selector string) Element
	MustGetText() string
	MustGetAttribute(name string) string
}
</file>

<file path="internal/infrastructure/interfaces/cloudflare.go">
package interfaces

type CloudflareBypasser interface {
	GetCookies(url string) ([]byte, error)
}
</file>

<file path="internal/interfaces/scraper.go">
package interfaces

import (
	"github.com/HumbeBee/hoe-crawler/internal/dto"
)

type Scraper interface {
	GetDetailURLs() ([]string, error)
	GetRawHoeData(url string) (*dto.RawHoeData, error)
}
</file>

<file path="internal/models/city.go">
package models

type City struct {
	ID          uint       `gorm:"primaryKey"`
	DisplayName string     `gorm:"column:display_name"`
	Name        string     `gorm:"column:name;index"`
	ShortName   string     `gorm:"column:short_name;index"`
	EngName     string     `gorm:"column:eng_name;index"`
	Code        string     `gorm:"column:code;index"`
	Districts   []District `gorm:"foreignKey:CityID;references:ID;constraint:OnDelete:CASCADE"`
}

func (City) TableName() string {
	return "cities"
}
</file>

<file path="internal/models/district.go">
package models

type District struct {
	ID          uint   `gorm:"primaryKey"`
	DisplayName string `gorm:"column:display_name"`
	Name        string `gorm:"column:name;index"`
	ShortName   string `gorm:"column:short_name;index"`
	EngName     string `gorm:"column:eng_name;index"`
	Code        string `gorm:"column:code;index"`
	CityID      uint   `gorm:"column:city_id;index"`

	City    City     `gorm:"foreignKey:CityID;"`
	Streets []Street `gorm:"foreignKey:DistrictID;references:ID;constraint:OnDelete:CASCADE"`
}

func (District) TableName() string {
	return "districts"
}
</file>

<file path="internal/models/hoe_profile.go">
package models

import (
	"database/sql/driver"
	"fmt"
	"time"
)

type HoeStatus string

type ParsedAddress struct {
	Street   string
	District string
}

const (
	HoeStatusActive   HoeStatus = "active"
	HoeStatusInactive HoeStatus = "inactive"
	HoeStatusUnknown  HoeStatus = "unknown"
)

type HoeProfile struct {
	ID        uint      `gorm:"primaryKey"`
	HoeID     uint      `gorm:"column:hoe_id"`
	SiteID    uint      `gorm:"column:site_id;index"`
	OriginID  string    `gorm:"column:origin_id"`
	Url       string    `gorm:"column:url"`
	ImageUrl  string    `gorm:"column:image_url"`
	Price     string    `gorm:"column:price"`
	Area      string    `gorm:"column:area"`
	Provider  string    `gorm:"column:provider"`
	Status    HoeStatus `gorm:"column:status;type:enum('active','inactive','unknown')"`
	Service   string    `gorm:"column:service"`
	Duration  string    `gorm:"column:duration"`
	WorkTime  string    `gorm:"column:work_time"`
	CreatedAt time.Time `gorm:"column:created_at"`
	UpdatedAt time.Time `gorm:"column:updated_at"`

	Hoe     HoeInfo     `gorm:"foreignKey:HoeID"`
	Site    Site        `gorm:"foreignKey:SiteID"`
	Reports []HoeReport `gorm:"foreignKey:HoeProfileID"`
}

func (p *HoeProfile) TableName() string {
	return "hoe_profiles"
}

// Using value receiver for Value() as we only need to read the status
// Using pointer receiver for Scan() as we need to modify the status
// This mixed receiver pattern is recommended by GORM
// Docs: https://gorm.io/docs/data_types.html

func (s HoeStatus) Value() (driver.Value, error) {
	return string(s), nil
}

func (s *HoeStatus) Scan(value interface{}) error {
	if value == nil {
		*s = HoeStatusUnknown
		return nil
	}

	str, ok := value.(string)
	if !ok {
		return fmt.Errorf("invalid status value: %v", value)
	}

	*s = HoeStatus(str)
	return nil
}
</file>

<file path="internal/models/hoe_report.go">
package models

import "time"

type HoeReport struct {
	ID           uint      `gorm:"primaryKey"`
	HoeProfileID uint      `gorm:"column:hoe_profile_id"`
	ReportURL    string    `gorm:"column:report_url"`
	CreatedAt    time.Time `gorm:"column:created_at"`
	UpdatedAt    time.Time `gorm:"column:updated_at"`

	Profile HoeProfile `gorm:"foreignKey:HoeProfileID"`
}

func (HoeReport) TableName() string {
	return "hoe_reports"
}
</file>

<file path="internal/models/hoe.go">
package models

import (
	"fmt"
	"time"
)

type HoeInfo struct {
	ID            uint      `gorm:"primaryKey"`
	Name          string    `gorm:"column:name"`
	Phone         string    `gorm:"column:phone;index;unique"`
	BirthYear     string    `gorm:"column:birth_year"`
	Height        string    `gorm:"column:height"`
	Weight        string    `gorm:"column:weight"`
	Country       string    `gorm:"column:country"`
	LastScrapedAt time.Time `gorm:"column:last_scraped_at"`
	CreatedAt     time.Time `gorm:"column:created_at"`
	UpdatedAt     time.Time `gorm:"column:updated_at"`

	// Site-specific profiles
	Profiles []HoeProfile `gorm:"foreignKey:HoeID;references:ID"`
	// Working histories
	WorkingHistories []WorkingHistory `gorm:"foreignKey:HoeID;references:ID"`
}

func (*HoeInfo) TableName() string {
	return "hoes"
}

func (h *HoeInfo) GetProfileBySite(siteID uint) *HoeProfile {
	for i := range h.Profiles {
		if h.Profiles[i].SiteID == siteID {
			return &h.Profiles[i]
		}
	}

	return nil
}

func (h *HoeInfo) GetCurrentScrapingProfile() (*HoeProfile, error) {
	if len(h.Profiles) == 0 {
		return nil, fmt.Errorf("hoe has no profile")
	}

	// Why Profiles[0] ?
	// Because the first profile is the one that is currently being scraped
	return &h.Profiles[0], nil
}

func (h *HoeInfo) Print() {
	fmt.Printf("=========== Hoe Info ===========\n")
	fmt.Printf("Name: %s\n", h.Name)
	fmt.Printf("Phone: %s\n", h.Phone)
	fmt.Printf("Birth Year: %s\n", h.BirthYear)
	fmt.Printf("Height: %s\n", h.Height)
	fmt.Printf("Weight: %s\n", h.Weight)
	fmt.Printf("Country: %s\n", h.Country)
	fmt.Printf("Last Scraped At: %s\n", h.LastScrapedAt)

	if len(h.Profiles) > 0 {
		fmt.Println("\n--- Latest Profile ---")
		profile := h.Profiles[0]
		fmt.Printf("Site: %s\n", profile.Site.Name)
		fmt.Printf("Original ID: %s\n", profile.OriginID)
		fmt.Printf("URL: %s\n", profile.Url)
		fmt.Printf("Image URL: %s\n", profile.ImageUrl)
		fmt.Printf("Price: %s\n", profile.Price)
		fmt.Printf("Area: %s\n", profile.Area)
		fmt.Printf("Provider: %s\n", profile.Provider)
		fmt.Printf("Status: %s\n", profile.Status)
		fmt.Printf("Service: %s\n", profile.Service)
		fmt.Printf("Duration: %s\n", profile.Duration)
		fmt.Printf("Work Time: %s\n", profile.WorkTime)
		fmt.Printf("Report Count: %d\n", len(profile.Reports))
	}

	fmt.Printf("\nTotal Profiles: %d\n", len(h.Profiles))
	fmt.Printf("Total Working Histories: %d\n", len(h.WorkingHistories))
	fmt.Println("==============================")
	fmt.Print("\n\n")
}
</file>

<file path="internal/models/hotel.go">
package models

type Hotel struct {
	ID         uint   `gorm:"primaryKey"`
	Name       string `gorm:"column:name;index"`
	EngName    string `gorm:"column:eng_name;index"`
	CityID     uint   `gorm:"column:city_id;index"`
	DistrictID uint   `gorm:"column:district_id;index"`

	City     City     `gorm:"foreignKey:CityID;references:ID;constraint:OnDelete:CASCADE"`
	District District `gorm:"foreignKey:DistrictID;references:ID;constraint:OnDelete:CASCADE"`
}

func (Hotel) TableName() string {
	return "hotels"
}
</file>

<file path="internal/models/reporter.go">
package models

type Reporter struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	Url  string `json:"url"`
}
</file>

<file path="internal/models/site.go">
package models

import "time"

type Site struct {
	ID        uint      `gorm:"primaryKey"`
	Name      string    `gorm:"column:name"`
	BaseURL   string    `gorm:"column:base_url"`
	IsExpired bool      `gorm:"column:is_expired"`
	CreatedAt time.Time `gorm:"column:created_at;autoCreateTime"`
	UpdatedAt time.Time `gorm:"column:updated_at;autoUpdateTime"`
}

func (Site) TableName() string {
	return "sites"
}
</file>

<file path="internal/models/street.go">
package models

type Street struct {
	ID         uint   `gorm:"primaryKey"`
	Name       string `gorm:"column:name"`
	Code       string `gorm:"column:code"`
	CityID     string `gorm:"column:city"`
	DistrictID uint   `gorm:"column:district_id;index"`

	City     City     `gorm:"foreignKey:CityID;references:ID;constraint:OnDelete:CASCADE"`
	District District `gorm:"foreignKey:DistrictID;references:ID;constraint:OnDelete:CASCADE"`
}

func (Street) TableName() string {
	return "street"
}
</file>

<file path="internal/models/working_history.go">
package models

import "time"

type WorkingHistory struct {
	ID         uint       `gorm:"primaryKey"`
	HoeID      uint       `gorm:"column:hoe_id;index"`
	StartDate  time.Time  `gorm:"column:start_date"`
	EndDate    *time.Time `gorm:"column:end_date"`
	CityID     uint       `gorm:"column:city_id;index"`
	DistrictID uint       `gorm:"column:district_id;index"`
	CreatedAt  time.Time  `gorm:"column:created_at"`
	UpdatedAt  time.Time  `gorm:"column:updated_at"`

	Hoe      HoeInfo  `gorm:"foreignKey:HoeID;"`
	City     City     `gorm:"foreignKey:CityID;references:ID;constraint:OnDelete:CASCADE"`
	District District `gorm:"foreignKey:DistrictID;references:ID;constraint:OnDelete:CASCADE"`
}

func (WorkingHistory) TableName() string {
	return "working_histories"
}
</file>

<file path="internal/repository/hoe.go">
package repository

import (
	"errors"
	"fmt"
	"time"

	"github.com/HumbeBee/hoe-crawler/internal/models"
	"github.com/HumbeBee/hoe-crawler/internal/utils/logutil"
	"gorm.io/gorm"
)

type HoeRepository interface {
	Save(hoe *models.HoeInfo) error
	GetHoeByPhone(phone string) (*models.HoeInfo, error)
}

type hoeRepo struct {
	db     *gorm.DB
	logger *logutil.Logger
}

func NewHoeRepository(db *gorm.DB, logger *logutil.Logger) HoeRepository {
	return &hoeRepo{db: db, logger: logger}
}

func (r *hoeRepo) Save(hoe *models.HoeInfo) error {
	tx := r.db.Begin()

	// Try to find existing hoe by phone
	var existingHoe models.HoeInfo
	err := tx.Where("phone = ?", hoe.Phone).First(&existingHoe).Error

	if errors.Is(err, gorm.ErrRecordNotFound) {
		// First time this hoe is scraped
		if err := tx.Create(hoe).Error; err != nil {
			tx.Rollback()
			return fmt.Errorf("failed to create new hoe: %v", err)
		}

		r.logger.Info(fmt.Sprintf("Created new hoe: %s with profile from %s",
			hoe.Name, hoe.Profiles[0].Site.Name))

	} else if err != nil {
		tx.Rollback()
		return fmt.Errorf("database error: %v", err)

	} else {
		// Hoe exists, handle profile update
		if err := r.updateExistingHoe(tx, &existingHoe, hoe); err != nil {
			tx.Rollback()
			return err
		}

		r.logger.Info(fmt.Sprintf("Updated existing hoe: %s with profile from %s",
			hoe.Name, hoe.Profiles[0].Site.Name))
	}

	return tx.Commit().Error
}

func (r *hoeRepo) updateExistingHoe(tx *gorm.DB, existing *models.HoeInfo, new *models.HoeInfo) error {
	// Update common info
	if err := tx.Model(existing).Updates(models.HoeInfo{
		Name:          new.Name,
		BirthYear:     new.BirthYear,
		Height:        new.Height,
		Weight:        new.Weight,
		Country:       new.Country,
		LastScrapedAt: time.Now(), // Always non-zero since it's current time
	}).Error; err != nil {
		return fmt.Errorf("failed to update hoe info: %v", err)
	}

	// Handle profile update
	newProfile := new.Profiles[0]
	var existingProfile models.HoeProfile

	err := tx.Where("hoe_id = ? AND site_id = ?",
		existing.ID, newProfile.SiteID).First(&existingProfile).Error

	if errors.Is(err, gorm.ErrRecordNotFound) {
		// First profile from this site
		newProfile.HoeID = existing.ID
		if err := tx.Create(&newProfile).Error; err != nil {
			return fmt.Errorf("failed to create new profile: %v", err)
		}
	} else if err != nil {
		return fmt.Errorf("database error: %v", err)
	} else {
		// Update existing profile
		if err := tx.Model(&existingProfile).Updates(models.HoeProfile{
			OriginID: newProfile.OriginID,
			Url:      newProfile.Url,
			ImageUrl: newProfile.ImageUrl,
			Price:    newProfile.Price,
			Provider: newProfile.Provider,
			Area:     newProfile.Area,
			Status:   newProfile.Status,
			Service:  newProfile.Service,
			Duration: newProfile.Duration,
			WorkTime: newProfile.WorkTime,
		}).Error; err != nil {
			return fmt.Errorf("failed to update profile: %v", err)
		}
	}

	return nil
}

func (r *hoeRepo) GetHoeByPhone(phone string) (*models.HoeInfo, error) {
	var hoe models.HoeInfo
	if err := r.db.Where("phone = ?", phone).First(&hoe).Error; err != nil {
		return nil, err
	}
	return &hoe, nil
}
</file>

<file path="internal/repository/location.go">
package repository

import (
	"github.com/HumbeBee/hoe-crawler/internal/models"
	"gorm.io/gorm"
)

type LocationRepository interface {
	CheckValidLocation(district string) error
	GetCityIDFromName(name string) (uint, error)
	GetDistrictIDFromName(name string) (uint, error)
}

type locationRepo struct {
	db *gorm.DB
}

func NewLocationRepository(db *gorm.DB) LocationRepository {
	return &locationRepo{db: db}
}

func (r *locationRepo) CheckValidLocation(district string) error {
	if err := r.db.Where("name = ?", district).Or("short_name = ?", district).Or("code = ? ", district).First(&models.District{}).Error; err != nil {
		return err
	}

	return nil
}

func (r *locationRepo) GetCityIDFromName(name string) (uint, error) {
	var city models.City
	if err := r.db.Where("name = ?", name).Or("short_name = ?", name).Or("code = ?", name).Or("eng_name = ?", name).Or("display_name = ?", name).Or("eng_name = ?", name+" city").First(&city).Error; err != nil {
		return 0, err
	}

	return city.ID, nil
}

func (r *locationRepo) GetDistrictIDFromName(name string) (uint, error) {
	var district models.District
	if err := r.db.Where("name = ?", name).Or("short_name = ?", name).Or("code = ?", name).Or("eng_name = ?", name).Or("display_name = ?", name).Or("eng_name = ?", name+" district").First(&district).Error; err != nil {
		return 0, err
	}

	return district.ID, nil
}
</file>

<file path="internal/repository/site.go">
package repository

import (
	"github.com/HumbeBee/hoe-crawler/internal/models"
	"gorm.io/gorm"
)

type SiteRepository interface {
	GetSiteByName(name string) (*models.Site, error)
}

type siteRepo struct {
	db *gorm.DB
}

func NewSiteRepository(db *gorm.DB) SiteRepository {
	return &siteRepo{db: db}
}

func (r *siteRepo) GetSiteByName(name string) (*models.Site, error) {
	var site models.Site
	if err := r.db.Model(&models.Site{}).Where("name = ?", name).First(&site).Error; err != nil {
		return nil, err
	}

	return &site, nil
}
</file>

<file path="internal/repository/working_history.go">
package repository

import (
	"github.com/HumbeBee/hoe-crawler/internal/models"
	"github.com/HumbeBee/hoe-crawler/internal/utils/logutil"
	"gorm.io/gorm"
)

type WorkingHistoryRepository interface {
	CheckIsNewLocation(cityID uint, districtID uint) (bool, error)
}

type workingHistory struct {
	db     *gorm.DB
	logger *logutil.Logger
}

func NewWorkingHistoryRepository(db *gorm.DB, logger *logutil.Logger) WorkingHistoryRepository {
	return &workingHistory{db: db, logger: logger}
}

func (w *workingHistory) CheckIsNewLocation(cityID uint, districtID uint) (bool, error) {
	var count int64
	if err := w.db.Model(&models.WorkingHistory{}).Where("city_id = ? AND district_id = ?", cityID, districtID).Count(&count).Error; err != nil {
		return false, err
	}

	return count == 0, nil
}
</file>

<file path="internal/scrapers/gaito/detail.go">
package gaito

import (
	"time"

	"github.com/HumbeBee/hoe-crawler/internal/dto"

	"github.com/HumbeBee/hoe-crawler/internal/infrastructure/browser"
	"github.com/HumbeBee/hoe-crawler/internal/models"
	"github.com/HumbeBee/hoe-crawler/internal/utils"
	"github.com/HumbeBee/hoe-crawler/internal/utils/errutil"
)

type detailPageScraper struct {
	siteID uint
	conn   *browser.Connection
	url    string
}

func newDetailPageScraper(conn *browser.Connection, url string, siteID uint) *detailPageScraper {
	return &detailPageScraper{conn: conn, url: url, siteID: siteID}
}

func (s *detailPageScraper) getBasicInfo() (*dto.RawHoeData, error) {
	id := utils.GetIDFromUrl(s.url)

	containerEle, err := s.conn.Root.Find(detailPageSelectors.PageContainer)
	if err != nil {
		return nil, errutil.WrapError("get container element", err, s.url)
	}

	detailInfoTabEle, err := containerEle.Find(detailPageSelectors.DetailInfoTab)
	if err != nil {
		return nil, errutil.WrapError("get detail info tab element", err, s.url)
	}

	rawInfo := &dto.RawHoeData{
		SiteID:   s.siteID,
		Url:      s.url,
		OriginID: id,
	}

	rawInfo.CityName = containerEle.MustFind(detailPageSelectors.CityName).MustGetText()
	rawInfo.DistrictName = containerEle.MustFind(detailPageSelectors.DistrictName).MustGetText()
	rawInfo.Name = containerEle.MustFind(detailPageSelectors.Name).MustGetText()
	rawInfo.ImageUrl = containerEle.MustFind(detailPageSelectors.ImageUrl).MustGetAttribute("src")
	rawInfo.Price = detailInfoTabEle.MustFind(detailPageSelectors.Price).MustGetText()
	rawInfo.Phone = detailInfoTabEle.MustFind(detailPageSelectors.Phone).MustGetText()
	rawInfo.Area = detailInfoTabEle.MustFind(detailPageSelectors.Address).MustGetText()
	rawInfo.Provider = detailInfoTabEle.MustFind(detailPageSelectors.Author).MustGetText()
	rawInfo.Status = detailInfoTabEle.MustFind(detailPageSelectors.Status).MustGetText()
	rawInfo.BirthYear = detailInfoTabEle.MustFind(detailPageSelectors.BirthYear).MustGetText()
	rawInfo.Height = detailInfoTabEle.MustFind(detailPageSelectors.Height).MustGetText()
	rawInfo.Weight = detailInfoTabEle.MustFind(detailPageSelectors.Weight).MustGetText()
	rawInfo.Country = detailInfoTabEle.MustFind(detailPageSelectors.Country).MustGetText()
	rawInfo.Service = detailInfoTabEle.MustFind(detailPageSelectors.Service).MustGetText()
	rawInfo.Duration = detailInfoTabEle.MustFind(detailPageSelectors.Duration).MustGetText()
	rawInfo.WorkTime = detailInfoTabEle.MustFind(detailPageSelectors.WorkTime).MustGetText()

	return rawInfo, nil
}

func (s *detailPageScraper) getReportURLs() ([]*models.HoeReport, error) {
	var reports []*models.HoeReport
	reportTabEle, err := s.conn.Root.Find(detailPageSelectors.ReportTab)
	if err != nil {
		return nil, errutil.WrapError("get report tab element", err, s.url)
	}

	if err := reportTabEle.Click(); err != nil {
		return nil, errutil.WrapError("click report tab element", err, s.url)
	}

	if err := reportTabEle.WaitVisible(); err != nil {
		return nil, errutil.WrapError("wait report tab element visible", err, s.url)
	}

	reportTabContentEle, err := s.conn.Root.Find(detailPageSelectors.ReportTabContent)
	if err != nil {
		return nil, errutil.WrapError("get report tab content element", err, s.url)
	}

	for {
		// reportsEle, err := browser.GetMultipleElementsWithRetry(reportTabContentEle, detailPageSelectors.ReportList)
		reportsEle, err := reportTabContentEle.FindAll(detailPageSelectors.ReportList)
		if err != nil {
			return nil, errutil.WrapError("get report elements", err, s.url)
		}

		for _, reportEle := range reportsEle {
			// reportUrl, err := browser.GetElementAttribute(reportEle, detailPageSelectors.ReportViewMoreBtn, "href")
			reportUrl, err := reportEle.MustFind(detailPageSelectors.ReportViewMoreBtn).GetAttribute("href")
			if err != nil {
				return nil, errutil.WrapError("get report url", err, s.url)
			}
			reports = append(reports, &models.HoeReport{
				ReportURL: reportUrl,
			})
		}

		goNextPageBtn, err := s.conn.Root.Find(detailPageSelectors.ReportGoNextPageBtn)
		if err != nil {
			break
		} else {
			// Click go next page button
			if err := goNextPageBtn.Click(); err != nil {
				return nil, errutil.WrapError("click go next page button", err, s.url)
			}

			time.Sleep(1 * time.Second)
		}
	}

	return reports, nil
}
</file>

<file path="internal/scrapers/gaito/list.go">
package gaito

import (
	"github.com/HumbeBee/hoe-crawler/internal/infrastructure/browser"
	"github.com/HumbeBee/hoe-crawler/internal/utils/errutil"
)

type listPageScraper struct {
	conn *browser.Connection
	url  string
}

func newListPageScraper(conn *browser.Connection, url string) *listPageScraper {
	return &listPageScraper{conn: conn, url: url}
}

func (s *listPageScraper) getHoeURLs() ([]string, error) {
	const (
		itemThreshold = 30
	)
	var urlList []string
	for {
		items, err := s.conn.Root.FindAll(listPageSelectors.Items)
		if err != nil {
			return nil, errutil.WrapError("get list items", err, s.url)
		}

		// currentLength >= itemThreshold: enough items
		// currentLength == 0: for some reason, the query doesn't return any items (Ex: Cloudflare, ...)
		currentLength := len(items)
		if currentLength >= itemThreshold || currentLength == 0 {
			break
		}

		loadMoreBtn, err := s.conn.Root.Find(listPageSelectors.LoadMoreBtn)
		if err != nil {
			break
		}

		if err := loadMoreBtn.Click(); err != nil {
			return nil, errutil.WrapError("click load more button", err, s.url)
		}

		if err := s.conn.Page.WaitElementsMoreThan(listPageSelectors.Items, currentLength); err != nil {
			return nil, errutil.WrapError("wait more items", err, s.url)
		}
	}

	elements, err := s.conn.Root.FindAll(listPageSelectors.Items)
	if err != nil {
		return nil, errutil.WrapError("get final list items", err, s.url)
	}

	for _, elem := range elements {
		urlList = append(urlList, elem.MustFind(listPageSelectors.ThumbnailUrl).MustGetAttribute("href"))
	}

	return urlList, nil
}
</file>

<file path="internal/scrapers/gaito/report.go">
package gaito

// import (
// 	"fmt"
// 	"strconv"

// 	"github.com/go-rod/rod"
// 	"github.com/HumbeBee/hoe-crawler/internal/models"
// 	"github.com/HumbeBee/hoe-crawler/internal/utils"
// 	"github.com/HumbeBee/hoe-crawler/internal/utils/browser"
// )

// func ProcessReportPage(reportUrl string) models.HoeReportInfo {
// 	url := BaseUrl + reportUrl
// 	id := utils.GetIDFromUrl(reportUrl)

// 	reportInfo := models.HoeReportInfo{
// 		ID:        id,
// 		DetailUrl: reportUrl,
// 	}

// 	page := rod.New().MustConnect().MustPage(url).MustWaitStable()
// 	element := page.MustElement(`review-detail-cmp`).MustWaitVisible()
// 	defer page.Close()

// 	stars, err := page.Elements(`span[ng-model="data.review.score"] i.fa-heart[ng-repeat="r in range track by $index"]`)
// 	if err != nil {
// 		panic(fmt.Errorf(`failed to get stars: %v`, err))
// 	}
// 	reportInfo.Rating = strconv.Itoa(len(stars))

// 	reportInfo.Description = browser.GetElementText(element, `div[ng-switch-when="textarea"] span[ng-bind="elem.question.response"]`, id+"_report_description")

// 	// Process author
// 	authorSectionElement, err := page.Element(`div.ow_page_padding > div > div > div > div > div > div:nth-child(3) > div > div.col-md-4 > div:nth-child(2) > div > div.ow_user_list_data`)
// 	if err != nil {
// 		panic(fmt.Errorf(`failed to get author section: %v`, err))
// 	}
// 	authorUrlElement := authorSectionElement.MustElement(`a.ng-binding`)
// 	authorUrl := authorUrlElement.MustAttribute(`href`)
// 	reportInfo.Author = &models.Reporter{
// 		ID:   utils.GetIDFromUrl(*authorUrl),
// 		Name: authorUrlElement.MustText(),
// 		Url:  *authorUrl,
// 	}
// 	reportInfo.Time = browser.GetElementText(element, `div.ow_page_padding > div > div > div > div > div > div:nth-child(3) > div > div.col-md-8 > review-detail-cmp > div:nth-child(1) > em > small`, id+"_report_time")

// 	return reportInfo
// }
</file>

<file path="internal/scrapers/gaito/scraper.go">
package gaito

import (
	"fmt"
	"time"

	"github.com/HumbeBee/hoe-crawler/internal/definitions"
	"github.com/HumbeBee/hoe-crawler/internal/dto"
	"github.com/HumbeBee/hoe-crawler/internal/infrastructure/browser"
)

type scraper struct {
	definitions.ScraperConfig
}

func NewScraper(config definitions.ScraperConfig) *scraper {
	return &scraper{
		config,
	}
}

func (s *scraper) GetDetailURLs() ([]string, error) {
	url := s.BaseURL + "/gai-goi/khu-vuc/Hồ%20Chí%20Minh/Quận%207"

	s.Logger.Info(fmt.Sprintf("Processing %s", url))

	conn, err := browser.ConnectToPage(url, 30*time.Second)
	if err != nil {
		return nil, fmt.Errorf("connect to page %s: %w", url, err)
	}
	defer conn.Close()

	listScraper := newListPageScraper(conn, url)
	return listScraper.getHoeURLs()
}

func (s *scraper) GetRawHoeData(detailUrl string) (*dto.RawHoeData, error) {
	url := s.BaseURL + detailUrl

	// Wait until content element is visible
	conn, err := browser.ConnectToPage(url, 5*time.Minute)
	if err != nil {
		return nil, fmt.Errorf("connect to detail page %s: %w", url, err)
	}
	defer conn.Close()

	detailScraper := newDetailPageScraper(conn, url, s.SiteID)
	hoeInfo, err := detailScraper.getBasicInfo()
	if err != nil {
		return nil, fmt.Errorf("get basic info %s: %w", url, err)
	}

	// Get report urls
	// reports, err := detailScraper.getReportURLs()
	// if err != nil {
	// 	return nil, errutil.WrapError("get report urls", err, url)
	// }

	// hoeInfo.Reports = reports
	return hoeInfo, nil
}
</file>

<file path="internal/scrapers/gaito/selectors.go">
package gaito

// ListPageSelectors contains all selectors used in list page scraping
type ListPageSelectors struct {
	Items        string
	LoadMoreBtn  string
	ThumbnailUrl string
}

type DetailPageSelectors struct {
	PageContainer  string
	DetailInfoTab  string
	DetailInfoCard string

	ReportTab           string
	ReportTabContent    string
	ReportList          string
	ReportViewMoreBtn   string
	ReportGoNextPageBtn string

	CityName     string
	DistrictName string
	Name         string
	ImageUrl     string
	Price        string
	Phone        string
	Address      string
	Author       string
	Status       string
	BirthYear    string
	Height       string
	Weight       string
	Country      string
	Service      string
	Duration     string
	WorkTime     string
}

var (
	listPageSelectors = ListPageSelectors{
		Items:        `div[ng-repeat="item in products"]`,
		LoadMoreBtn:  `body > div.container.seduction-container > div.knn_page_wrap > div.ow_page_padding > div > div > div > div > div > div:nth-child(3) > div:nth-child(4) > div > button`,
		ThumbnailUrl: `.thumbnail a`,
	}

	detailPageSelectors = DetailPageSelectors{
		PageContainer:  `.container.seduction-container .ow_page_container`,
		DetailInfoTab:  `.tab-content`,
		DetailInfoCard: `.jumbotron.ng-scope`,

		ReportTab:           `li[index="2"] a.nav-link`,
		ReportTabContent:    `product-review[ng-if="reviewTabLoaded"] div.panel-body`,
		ReportList:          `div[ng-repeat="review in reviews"]`,
		ReportViewMoreBtn:   `a.view_more_report`,
		ReportGoNextPageBtn: `product-review li.pagination-next:not(.disabled) a[ng-click]`,

		CityName:     `.breadcrumb > li:nth-child(3) > a > span`,
		DistrictName: `.breadcrumb > li:nth-child(4) > a > span`,
		Name:         `div:nth-child(3) > div > h1`,
		ImageUrl:     `div:nth-child(3) > div > div:nth-child(3) > div > div > div > div.tab-pane.ng-scope.active > div.jumbotron.ng-scope > div > div.col-md-3.col-sm-4.media.escort_item_wrap > div > image-placeholder > img`,
		Price:        `.jumbotron .fa.fa-money + span`,
		Phone:        `.jumbotron .fa.fa-phone + a`,
		Address:      `.jumbotron .fa.fa-map-marker + a`,
		Author:       `.jumbotron .fa.fa-user + a`,
		Status:       `.jumbotron .fa.fa-file-o + span`,
		BirthYear:    `product-attribute table > tbody > tr:nth-child(3) > td:nth-child(2) > attribute-dob-box > div > div`,
		Height:       `product-attribute table > tbody > tr:nth-child(4) > td:nth-child(2) > attribute-number-box .ng-scope`,
		Weight:       `product-attribute table > tbody > tr:nth-child(5) > td:nth-child(2) > attribute-number-box .ng-scope`,
		Country:      `product-attribute table > tbody > tr:nth-child(9) > td:nth-child(2) > attribute-radio-box span span[ng-repeat="item in attributeDto.settings.values"]`,
		Service:      `product-attribute table > tbody > tr:nth-child(12) > td:nth-child(2) > attribute-choices-box span span[ng-repeat="item in attributeDto.settings.values"]`,
		Duration:     `product-attribute table > tbody > tr:nth-child(15) > td:nth-child(2) > attribute-text-box span`,
		WorkTime:     `product-attribute table > tbody > tr:nth-child(16) > td:nth-child(2) > attribute-text-box span`,
	}
)
</file>

<file path="internal/scrapers/factory.go">
package scrapers

import (
	"github.com/HumbeBee/hoe-crawler/internal/definitions"
	"github.com/HumbeBee/hoe-crawler/internal/interfaces"
	"github.com/HumbeBee/hoe-crawler/internal/scrapers/gaito"
)

func CreateScraper(baseConfig definitions.ScraperConfig) interfaces.Scraper {
	switch baseConfig.SiteName {
	case "gaito":
		return gaito.NewScraper(baseConfig)
	case "gaigu":
		return gaito.NewScraper(baseConfig)
	default:
		return nil
	}
}
</file>

<file path="internal/service/hoe_builder.go">
package service

import (
	"errors"

	"github.com/HumbeBee/hoe-crawler/internal/interfaces"
	"github.com/HumbeBee/hoe-crawler/internal/repository"
	"github.com/HumbeBee/hoe-crawler/internal/utils/logutil"
)

type HoeBuilder struct {
	hoeRepo            repository.HoeRepository
	workingHistoryRepo repository.WorkingHistoryRepository
	locationRepo       repository.LocationRepository
	logger             *logutil.Logger
	scraper            interfaces.Scraper
}

func NewHoeBuilder() *HoeBuilder {
	return &HoeBuilder{}
}

func (b *HoeBuilder) WithHoeRepo(hoeRepo repository.HoeRepository) *HoeBuilder {
	b.hoeRepo = hoeRepo
	return b
}

func (b *HoeBuilder) WithWorkingHistoryRepo(workingHistoryRepo repository.WorkingHistoryRepository) *HoeBuilder {
	b.workingHistoryRepo = workingHistoryRepo
	return b
}

func (b *HoeBuilder) WithLocationRepo(locationRepo repository.LocationRepository) *HoeBuilder {
	b.locationRepo = locationRepo
	return b
}

func (b *HoeBuilder) WithLogger(logger *logutil.Logger) *HoeBuilder {
	b.logger = logger
	return b
}

func (b *HoeBuilder) WithScraper(scraper interfaces.Scraper) *HoeBuilder {
	b.scraper = scraper
	return b
}

func (b *HoeBuilder) validate() error {
	if b.hoeRepo == nil {
		return errors.New("hoeRepo is required")
	}
	if b.workingHistoryRepo == nil {
		return errors.New("workingHistoryRepo is required")
	}
	if b.locationRepo == nil {
		return errors.New("locationRepo is required")
	}
	if b.scraper == nil {
		return errors.New("scraper is required")
	}

	// Set defaults for optional stuff
	if b.logger == nil {
		b.logger = logutil.NewLogger(logutil.INFO)
	}

	return nil
}

func (b *HoeBuilder) Build() (HoeService, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}

	return &hoeService{
		locationRepo:       b.locationRepo,
		hoeRepo:            b.hoeRepo,
		workingHistoryRepo: b.workingHistoryRepo,
		logger:             b.logger,
		scraper:            b.scraper,
		mapperService:      NewMapperService(),
		validateService:    NewValidateService(),
	}, nil
}
</file>

<file path="internal/service/hoe.go">
package service

import (
	"fmt"

	"github.com/HumbeBee/hoe-crawler/internal/definitions"
	"github.com/HumbeBee/hoe-crawler/internal/models"

	"github.com/HumbeBee/hoe-crawler/internal/interfaces"
	"github.com/HumbeBee/hoe-crawler/internal/repository"
	"github.com/HumbeBee/hoe-crawler/internal/utils/errutil"
	"github.com/HumbeBee/hoe-crawler/internal/utils/logutil"
)

type HoeService interface {
	ProcessListPage() error
	ProcessDetailPage(url string) error
}

type hoeService struct {
	locationRepo       repository.LocationRepository
	hoeRepo            repository.HoeRepository
	workingHistoryRepo repository.WorkingHistoryRepository
	logger             *logutil.Logger
	scraper            interfaces.Scraper
	mapperService      definitions.MapperService
	validateService    definitions.ValidateService
}

func (hs *hoeService) ProcessListPage() error {
	detailURLs, err := hs.scraper.GetDetailURLs()
	if err != nil {
		return errutil.WrapError("get detail urls", err, "no target")
	}

	if len(detailURLs) == 0 {
		hs.logger.Warn("No items found (Maybe Cloudflare block ?)")
	} else {
		hs.logger.Info(fmt.Sprintf("Found %d items\n", len(detailURLs)))

		for _, url := range detailURLs {
			hs.logger.Info(url)
		}
	}

	return nil
}

func (hs *hoeService) ProcessDetailPage(url string) error {
	url2 := "/gai-goi/chi-tiet/56042/hot-girl-diep-anhmat-xinh-nguc-dep-bu-cu-dieu-luyen"

	rawHoe, err := hs.scraper.GetRawHoeData(url2)
	if err != nil {
		return errutil.WrapError("get raw hoe data", err, url)
	}

	// If we can get location from database, it mean the location is already valid
	cityID, err := hs.locationRepo.GetCityIDFromName(rawHoe.CityName)
	if err != nil {
		return errutil.WrapError("get city id", err, rawHoe.CityName)
	}
	districtID, err := hs.locationRepo.GetDistrictIDFromName(rawHoe.DistrictName)
	if err != nil {
		return errutil.WrapError("get district id", err, rawHoe.DistrictName)
	}

	// raw data to domain models
	hoeInfo := hs.mapperService.TransformHoe(rawHoe)

	isNewLocation, err := hs.workingHistoryRepo.CheckIsNewLocation(cityID, districtID)
	if err != nil {
		return errutil.WrapError("check is new location", err, rawHoe.CityName)
	}
	if isNewLocation {
		// Create new working history
		hoeInfo.WorkingHistories = append(hoeInfo.WorkingHistories, models.WorkingHistory{
			CityID:     cityID,
			DistrictID: districtID,
		})
	}

	hoeInfo.Print()
	//
	//if err := hs.validateService.ValidateHoe(hoeInfo); err != nil {
	//	return err
	//}
	//
	//hoeInfo.Print()

	return nil
}
</file>

<file path="internal/service/mapper.go">
package service

import (
	"strings"

	"github.com/HumbeBee/hoe-crawler/internal/definitions"
	"github.com/HumbeBee/hoe-crawler/internal/dto"
	"github.com/HumbeBee/hoe-crawler/internal/models"
)

type mapperService struct{}

func NewMapperService() definitions.MapperService {
	return &mapperService{}
}

func (s *mapperService) TransformHoe(rawInfo *dto.RawHoeData) *models.HoeInfo {
	rawInfo.Price = s.normalizePrice(rawInfo.Price)
	rawInfo.Phone = s.normalizePhone(rawInfo.Phone)

	return &models.HoeInfo{
		Name:      strings.TrimSpace(rawInfo.Name),
		Phone:     rawInfo.Phone,
		BirthYear: rawInfo.BirthYear,
		Height:    rawInfo.Height,
		Weight:    rawInfo.Weight,
		Country:   rawInfo.Country,

		Profiles: []models.HoeProfile{
			{
				SiteID:   rawInfo.SiteID,
				OriginID: rawInfo.OriginID,
				Url:      rawInfo.Url,
				ImageUrl: rawInfo.ImageUrl,
				Price:    rawInfo.Price,
				Area:     rawInfo.Area,
				Provider: rawInfo.Provider,
				Status:   s.mapStatus(rawInfo.Status),
				Service:  rawInfo.Service,
				Duration: rawInfo.Duration,
				WorkTime: rawInfo.WorkTime,
			},
		},
	}
}

func (s *mapperService) normalizePrice(price string) string {
	// First clean up any special characters and spaces
	price = strings.ReplaceAll(price, "\u00A0", "")
	price = strings.ReplaceAll(price, ",", "")
	price = strings.ToLower(price)

	// Remove any spaces
	price = strings.ReplaceAll(price, " ", "")

	// Remove 'k' and 'vnd'
	price = strings.ReplaceAll(price, "k", "")
	price = strings.ReplaceAll(price, "vnd", "")

	return price
}

func (s *mapperService) normalizePhone(phone string) string {
	phone = strings.ReplaceAll(phone, ".", "")
	phone = strings.ReplaceAll(phone, "-", "")
	phone = strings.ReplaceAll(phone, " ", "")

	return phone
}

func (s *mapperService) mapStatus(status string) models.HoeStatus {
	status = strings.ToLower(strings.TrimSpace(status))
	switch status {
	case "đang rảnh", "online", "hoạt động":
		return models.HoeStatusActive
	case "bận", "offline":
		return models.HoeStatusInactive
	default:
		return models.HoeStatusUnknown
	}
}
</file>

<file path="internal/service/validate.go">
package service

import (
	"github.com/HumbeBee/hoe-crawler/internal/definitions"
	"github.com/HumbeBee/hoe-crawler/internal/models"

	"strings"
)

type validateService struct {
}

func NewValidateService() definitions.ValidateService {
	return &validateService{}
}

func (s *validateService) ValidateHoe(hoe *models.HoeInfo) error {

	return nil
}

func parseLocation(location string) definitions.ParsedAddress {
	// Trim any leading/trailing whitespace
	location = strings.TrimSpace(location)

	// Split the address into parts
	parts := strings.Split(location, ",")

	parsed := definitions.ParsedAddress{
		Street:   "",
		District: "",
	}

	if len(parts) >= 1 {
		parsed.Street = strings.TrimSpace(parts[0])
	}

	if len(parts) >= 2 {
		// Handle potential district abbreviations
		district := strings.TrimSpace(parts[1])
		district = strings.ReplaceAll(district, "Q.", "Quận ")
		district = strings.ReplaceAll(district, "Quan ", "Quận ")
		parsed.District = district
	}

	return parsed
}
</file>

<file path="internal/utils/errutil/handler.go">
package errutil

import (
	"runtime"
	"strings"
)

type ScrapeError struct {
	Op     string // Operation being performed
	Target string // Target being scraped (URL, selector, etc)
	Err    error  // Original error
	File   string // Source file where error occurred
	Line   int    // Line number where error occurred
}

func (se *ScrapeError) Error() string {
	parts := []string{se.Op}

	if se.Target != "" {
		parts = append(parts, "target: "+se.Target)
	}
	if se.Err != nil {
		parts = append(parts, "error: "+se.Err.Error())
	}

	return strings.Join(parts, " - ")
}

func WrapError(op string, err error, target string) error {
	if err == nil {
		return nil
	}

	_, file, line, _ := runtime.Caller(1)

	serr := &ScrapeError{
		Op:     op,
		Target: target,
		Err:    err,
		File:   file,
		Line:   line,
	}

	return serr
}
</file>

<file path="internal/utils/logutil/handler.go">
package logutil

import (
	"log"
	"os"
)

type Logger struct {
	logger   *log.Logger
	minLevel LogLevel
}

func NewLogger(minLevel LogLevel) *Logger {
	return &Logger{
		logger:   log.Default(),
		minLevel: minLevel,
	}
}

func (l *Logger) Log(level LogLevel, msg string, args ...interface{}) {
	if level >= l.minLevel {
		l.logger.Printf("["+level.String()+"] "+msg, args...)
	}
}

func (l *Logger) Debug(msg string, args ...interface{}) {
	l.Log(DEBUG, msg, args...)
}

func (l *Logger) Info(msg string, args ...interface{}) {
	l.Log(INFO, msg, args...)
}

func (l *Logger) Warn(msg string, args ...interface{}) {
	l.Log(WARN, msg, args...)
}

func (l *Logger) Error(msg string, args ...interface{}) {
	l.Log(ERROR, msg, args...)
}

func (l *Logger) Fatal(msg string, args ...interface{}) {
	l.Log(FATAL, msg, args...)
	// panic(msg) // or os.Exit(1) depending on your needs
	os.Exit(1)
}
</file>

<file path="internal/utils/logutil/level.go">
package logutil

import (
	"fmt"
	"strings"
)

type LogLevel int

const (
	DEBUG LogLevel = iota
	INFO
	WARN
	ERROR
	FATAL
)

func (l LogLevel) String() string {
	switch l {
	case DEBUG:
		return "DEBUG"
	case INFO:
		return "INFO"
	case WARN:
		return "WARN"
	case ERROR:
		return "ERROR"
	case FATAL:
		return "FATAL"
	default:
		return "UNKNOWN"
	}
}

func ParseLogLevel(level string) (LogLevel, error) {
	switch strings.ToUpper(level) {
	case "DEBUG":
		return DEBUG, nil
	case "INFO":
		return INFO, nil
	case "WARN":
		return WARN, nil
	case "ERROR":
		return ERROR, nil
	case "FATAL":
		return FATAL, nil
	default:
		return INFO, fmt.Errorf("unknown log level: %s", level)
	}
}
</file>

<file path="internal/utils/setuputil/setup.go">
package setuputil

import (
	"flag"
	"fmt"
	"log"
	"os"

	"github.com/HumbeBee/hoe-crawler/internal/definitions"
	"github.com/HumbeBee/hoe-crawler/internal/infrastructure/database"
	"github.com/HumbeBee/hoe-crawler/internal/interfaces"
	"github.com/HumbeBee/hoe-crawler/internal/repository"
	"github.com/HumbeBee/hoe-crawler/internal/scrapers"
	"github.com/HumbeBee/hoe-crawler/internal/service"
	"github.com/HumbeBee/hoe-crawler/internal/utils/logutil"
)

type AppContext struct {
	Scraper    interfaces.Scraper
	HoeService service.HoeService
	Logger     *logutil.Logger
}

func InitLogger() *logutil.Logger {
	log.SetFlags(log.LstdFlags)

	logLevelStr := os.Getenv("LOG_LEVEL")
	logLevel, err := logutil.ParseLogLevel(logLevelStr)
	if err != nil {
		log.Printf("Invalid log level '%s', defaulting to INFO", logLevelStr)
		logLevel = logutil.INFO
	}

	return logutil.NewLogger(logLevel)
}

func CreateAppContext() (*AppContext, error) {
	// Get site from cmd options
	site := flag.String("site", "gaito", "The site to scrape")
	flag.Parse()

	logger := InitLogger()

	db, err := database.InitDB()
	if err != nil {
		return nil, fmt.Errorf("failed to initialize database: %w", err)
	}

	siteRepo := repository.NewSiteRepository(db)
	siteInfo, err := siteRepo.GetSiteByName(*site)

	if err != nil {
		return nil, fmt.Errorf("failed to get site by name: %w", err)
	}

	baseConfig := definitions.ScraperConfig{
		SiteID:            siteInfo.ID,
		SiteName:          siteInfo.Name,
		BaseURL:           siteInfo.BaseURL,
		RequestsPerSecond: 1.0,
		Logger:            logger,
	}

	scraper := scrapers.CreateScraper(baseConfig)

	hoeRepo := repository.NewHoeRepository(db, logger)
	locationRepo := repository.NewLocationRepository(db)
	workingHistoryRepo := repository.NewWorkingHistoryRepository(db, logger)

	hoeService, err := service.NewHoeBuilder().
		WithHoeRepo(hoeRepo).
		WithWorkingHistoryRepo(workingHistoryRepo).
		WithLocationRepo(locationRepo).
		WithLogger(logger).
		WithScraper(scraper).
		Build()

	if err != nil {
		return nil, fmt.Errorf("failed to create hoe service: %w", err)
	}

	return &AppContext{
		Scraper:    scraper,
		Logger:     logger,
		HoeService: hoeService,
	}, nil
}
</file>

<file path="internal/utils/common.go">
package utils

import (
	"fmt"
	"regexp"
	"strings"
)

func GetIDFromUrl(url string) string {
	url = strings.TrimSuffix(url, "/")

	// Pattern 1: "/x/y/id/z" - extract ID between segments
	re1 := regexp.MustCompile(`/([^/]+)/[^/]+$`)
	if match := re1.FindStringSubmatch(url); len(match) >= 2 {
		return match[1]
	}

	// Pattern 2: "/a/id" - extract ID at the end
	re2 := regexp.MustCompile(`/([^/]+)$`)
	if match := re2.FindStringSubmatch(url); len(match) >= 2 {
		return match[1]
	}

	return ""
}

func HandleError(err error, operation string, fieldName string) {
	if err != nil {
		panic(fmt.Errorf(`failed to %s "%s": %v`, operation, fieldName, err))
	}
}
</file>

<file path=".env.example">
# .env.example
MYSQL_ROOT_PASSWORD=your_root_password
DB_HOST=localhost
DB_PORT=3306
DB_USER=your_username
DB_PASSWORD=your_password
DB_NAME=your_database

LOG_LEVEL=INFO
</file>

<file path=".gitignore">
# Binary files
*.exe
*.exe~
*.dll
*.so
*.dylib

# Binary folder (common Go build output)
/bin/

# Go specific
*.test
*.out

# IDE stuff
.idea/
.vscode/
*.swp
*.swo

# OS generated files
.DS_Store
.DS_Store?
._*

# Environment files
.env
.env.local
.env.development
.env.production

# repomix
repomix-output.txt
</file>

<file path="docker-compose.yml">
services:
  mariadb:
    image: mariadb:11.6-ubi
    container_name: hoe-crawler-db
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${DB_NAME}
      MYSQL_USER: ${DB_USER}
      MYSQL_PASSWORD: ${DB_PASSWORD}
    ports:
      - "${DB_PORT}:3306"
    volumes:
      - hoe_crawler_mariadb_data:/var/lib/mysql

volumes:
  hoe_crawler_mariadb_data:
</file>

<file path="go.mod">
module github.com/HumbeBee/hoe-crawler

go 1.23

toolchain go1.23.2

require (
	github.com/chromedp/cdproto v0.0.0-20241014181340-cb3a7a1d51d7
	github.com/chromedp/chromedp v0.11.0
)

require (
	filippo.io/edwards25519 v1.1.0 // indirect
	github.com/chromedp/sysutil v1.1.0 // indirect
	github.com/go-rod/rod v0.116.2 // indirect
	github.com/go-rod/stealth v0.4.9 // indirect
	github.com/go-sql-driver/mysql v1.8.1 // indirect
	github.com/gobwas/httphead v0.1.0 // indirect
	github.com/gobwas/pool v0.2.1 // indirect
	github.com/gobwas/ws v1.4.0 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/joho/godotenv v1.5.1 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/ysmood/fetchup v0.2.4 // indirect
	github.com/ysmood/goob v0.4.0 // indirect
	github.com/ysmood/got v0.40.0 // indirect
	github.com/ysmood/gson v0.7.3 // indirect
	github.com/ysmood/leakless v0.9.0 // indirect
	golang.org/x/sys v0.26.0 // indirect
	golang.org/x/text v0.20.0 // indirect
	gorm.io/driver/mysql v1.5.7 // indirect
	gorm.io/gorm v1.25.12 // indirect
)
</file>

<file path="go.sum">
filippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=
filippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=
github.com/chromedp/cdproto v0.0.0-20241003230502-a4a8f7c660df/go.mod h1:GKljq0VrfU4D5yc+2qA6OVr8pmO/MBbPEWqWQ/oqGEs=
github.com/chromedp/cdproto v0.0.0-20241014181340-cb3a7a1d51d7 h1:VDBgUGgdCBw9lTKwp0KPExhnqmGfGVJQTER2MehoICk=
github.com/chromedp/cdproto v0.0.0-20241014181340-cb3a7a1d51d7/go.mod h1:GKljq0VrfU4D5yc+2qA6OVr8pmO/MBbPEWqWQ/oqGEs=
github.com/chromedp/chromedp v0.11.0 h1:1PT6O4g39sBAFjlljIHTpxmCSk8meeYL6+R+oXH4bWA=
github.com/chromedp/chromedp v0.11.0/go.mod h1:jsD7OHrX0Qmskqb5Y4fn4jHnqquqW22rkMFgKbECsqg=
github.com/chromedp/sysutil v1.0.0/go.mod h1:kgWmDdq8fTzXYcKIBqIYvRRTnYb9aNS9moAV0xufSww=
github.com/chromedp/sysutil v1.1.0 h1:PUFNv5EcprjqXZD9nJb9b/c9ibAbxiYo4exNWZyipwM=
github.com/chromedp/sysutil v1.1.0/go.mod h1:WiThHUdltqCNKGc4gaU50XgYjwjYIhKWoHGPTUfWTJ8=
github.com/go-rod/rod v0.113.0/go.mod h1:aiedSEFg5DwG/fnNbUOTPMTTWX3MRj6vIs/a684Mthw=
github.com/go-rod/rod v0.116.2 h1:A5t2Ky2A+5eD/ZJQr1EfsQSe5rms5Xof/qj296e+ZqA=
github.com/go-rod/rod v0.116.2/go.mod h1:H+CMO9SCNc2TJ2WfrG+pKhITz57uGNYU43qYHh438Mg=
github.com/go-rod/stealth v0.4.9 h1:X2PmQk4DUF2wzw6GOsWjW/glb8K5ebnftbEvLh7MlZ4=
github.com/go-rod/stealth v0.4.9/go.mod h1:eAzyvw8c0iAd5nJJsSWeh0fQ5z94vCIfdi1hUmYDimc=
github.com/go-sql-driver/mysql v1.7.0/go.mod h1:OXbVy3sEdcQ2Doequ6Z5BW6fXNQTmx+9S1MCJN5yJMI=
github.com/go-sql-driver/mysql v1.8.1 h1:LedoTUt/eveggdHS9qUFC1EFSa8bU2+1pZjSRpvNJ1Y=
github.com/go-sql-driver/mysql v1.8.1/go.mod h1:wEBSXgmK//2ZFJyE+qWnIsVGmvmEKlqwuVSjsCm7DZg=
github.com/gobwas/httphead v0.1.0 h1:exrUm0f4YX0L7EBwZHuCF4GDp8aJfVeBrlLQrs6NqWU=
github.com/gobwas/httphead v0.1.0/go.mod h1:O/RXo79gxV8G+RqlR/otEwx4Q36zl9rqC5u12GKvMCM=
github.com/gobwas/pool v0.2.1 h1:xfeeEhW7pwmX8nuLVlqbzVc7udMDrwetjEv+TZIz1og=
github.com/gobwas/pool v0.2.1/go.mod h1:q8bcK0KcYlCgd9e7WYLm9LpyS+YeLd8JVDW6WezmKEw=
github.com/gobwas/ws v1.4.0 h1:CTaoG1tojrh4ucGPcoJFiAQUAsEWekEWvLy7GsVNqGs=
github.com/gobwas/ws v1.4.0/go.mod h1:G3gNqMNtPppf5XUz7O4shetPpcZ1VJ7zt18dlUeakrc=
github.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=
github.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=
github.com/jinzhu/now v1.1.5 h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=
github.com/jinzhu/now v1.1.5/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
github.com/ledongthuc/pdf v0.0.0-20220302134840-0c2507a12d80 h1:6Yzfa6GP0rIo/kULo2bwGEkFvCePZ3qHDDTC3/J9Swo=
github.com/ledongthuc/pdf v0.0.0-20220302134840-0c2507a12d80/go.mod h1:imJHygn/1yfhB7XSJJKlFZKl/J+dCPAknuiaGOshXAs=
github.com/mailru/easyjson v0.7.7 h1:UGYAvKxe3sBsEDzO8ZeWOSlIQfWFlxbzLZe7hwFURr0=
github.com/mailru/easyjson v0.7.7/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=
github.com/orisano/pixelmatch v0.0.0-20220722002657-fb0b55479cde h1:x0TT0RDC7UhAVbbWWBzr41ElhJx5tXPWkIHA2HWPRuw=
github.com/orisano/pixelmatch v0.0.0-20220722002657-fb0b55479cde/go.mod h1:nZgzbfBr3hhjoZnS66nKrHmduYNpc34ny7RK4z5/HM0=
github.com/ysmood/fetchup v0.2.3 h1:ulX+SonA0Vma5zUFXtv52Kzip/xe7aj4vqT5AJwQ+ZQ=
github.com/ysmood/fetchup v0.2.3/go.mod h1:xhibcRKziSvol0H1/pj33dnKrYyI2ebIvz5cOOkYGns=
github.com/ysmood/fetchup v0.2.4 h1:2kfWr/UrdiHg4KYRrxL2Jcrqx4DZYD+OtWu7WPBZl5o=
github.com/ysmood/fetchup v0.2.4/go.mod h1:hbysoq65PXL0NQeNzUczNYIKpwpkwFL4LXMDEvIQq9A=
github.com/ysmood/goob v0.4.0 h1:HsxXhyLBeGzWXnqVKtmT9qM7EuVs/XOgkX7T6r1o1AQ=
github.com/ysmood/goob v0.4.0/go.mod h1:u6yx7ZhS4Exf2MwciFr6nIM8knHQIE22lFpWHnfql18=
github.com/ysmood/gop v0.0.2/go.mod h1:rr5z2z27oGEbyB787hpEcx4ab8cCiPnKxn0SUHt6xzk=
github.com/ysmood/got v0.34.1/go.mod h1:yddyjq/PmAf08RMLSwDjPyCvHvYed+WjHnQxpH851LM=
github.com/ysmood/got v0.40.0 h1:ZQk1B55zIvS7zflRrkGfPDrPG3d7+JOza1ZkNxcc74Q=
github.com/ysmood/got v0.40.0/go.mod h1:W7DdpuX6skL3NszLmAsC5hT7JAhuLZhByVzHTq874Qg=
github.com/ysmood/gotrace v0.6.0/go.mod h1:TzhIG7nHDry5//eYZDYcTzuJLYQIkykJzCRIo4/dzQM=
github.com/ysmood/gson v0.7.3 h1:QFkWbTH8MxyUTKPkVWAENJhxqdBa4lYTQWqZCiLG6kE=
github.com/ysmood/gson v0.7.3/go.mod h1:3Kzs5zDl21g5F/BlLTNcuAGAYLKt2lV5G8D1zF3RNmg=
github.com/ysmood/leakless v0.8.0/go.mod h1:R8iAXPRaG97QJwqxs74RdwzcRHT1SWCGTNqY8q0JvMQ=
github.com/ysmood/leakless v0.9.0 h1:qxCG5VirSBvmi3uynXFkcnLMzkphdh3xx5FtrORwDCU=
github.com/ysmood/leakless v0.9.0/go.mod h1:R8iAXPRaG97QJwqxs74RdwzcRHT1SWCGTNqY8q0JvMQ=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.26.0 h1:KHjCJyddX0LoSTb3J+vWpupP9p0oznkqVk/IfjymZbo=
golang.org/x/sys v0.26.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/text v0.20.0 h1:gK/Kv2otX8gz+wn7Rmb3vT96ZwuoxnQlY+HlJVj7Qug=
golang.org/x/text v0.20.0/go.mod h1:D4IsuqiFMhST5bX19pQ9ikHC2GsaKyk/oF+pn3ducp4=
gorm.io/driver/mysql v1.5.7 h1:MndhOPYOfEp2rHKgkZIhJ16eVUIRf2HmzgoPmh7FCWo=
gorm.io/driver/mysql v1.5.7/go.mod h1:sEtPWMiqiN1N1cMXoXmBbd8C6/l+TESwriotuRRpkDM=
gorm.io/gorm v1.25.7/go.mod h1:hbnx/Oo0ChWMn1BIhpy1oYozzpM15i4YPuHDmfYtwg8=
gorm.io/gorm v1.25.12 h1:I0u8i2hWQItBq1WfE0o2+WuL9+8L21K9e2HHSTE/0f8=
gorm.io/gorm v1.25.12/go.mod h1:xh7N7RHfYlNc5EmcI/El95gXusucDrQnHXe0+CgWcLQ=
</file>

<file path="README.md">
Instruct how to setup
</file>

</repository_files>
